/** @file Security.h
 * Make complex cryptographic mecanisms easy to use.
 * @author Adrien RICCIARDI
 * @version 1.0 : 13/01/2014
 * @version 1.1 : 23/01/2014, splitted in several files to make security module simpler.
 */
#ifndef H_SECURITY_H
#define H_SECURITY_H

#include <gmp.h>
#include <openssl/evp.h>
#include "Crypto/Elliptic_Curves.h"
#include "Crypto/Point.h"
#include "Robot.h"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Constants
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Maximum video streaming buffer size in bytes. */
#define SECURITY_VIDEO_BUFFER_MAXIMUM_SIZE_BYTES 65568

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Types
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Format of an authentication message used to establish secure connection. */
typedef struct __attribute__((packed))
{
	int Counter; //! The counter value.
	char Key_Part_X[ELLIPTIC_CURVE_SIZE_BYTES]; //! The Diffie-Hellman key part point X coordinate.
	char Key_Part_Y[ELLIPTIC_CURVE_SIZE_BYTES]; //! The Diffie-Hellman key part point Y coordinate.
	char Signature_Number_U[ELLIPTIC_CURVE_SIZE_BYTES]; //! U number of the ECDSA signature.
	char Signature_Number_V[ELLIPTIC_CURVE_SIZE_BYTES]; //! V number of the ECDSA signature.
} TSecurityMessageAuthentication;

/** Message used to communicate commands and control data to the robot. */
typedef struct __attribute__((packed))
{
	int Data; //! The message data.
	char Hash[UTILS_HASH_SIZE_BYTES]; //! Hash of the message payload used to check integrity.
	char Padding[12]; //! Padding needed to alignate message on AES blocks size.
} TSecurityMessageRobotControl;

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Functions
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
/** Generate three key pairs files based on the specified elliptic curve for Jupiter, Polyphemus and Io machines.
 * @param String_Elliptic_Curve_File_Path Path to an ARCANA Weierstrass elliptic curve file of (SECURITY_ELLIPTIC_CURVE_SIZE_BYTES * 8) bits.
 * @param String_Jupiter_File_Path On output, create a key file for Jupiter.
 * @param String_Polyphemus_File_Path On output, create a key file for Polyphemus.
 * @param String_Io_File_Path On output, create a key file for Io.
 * @return 0 if the key files were successfully generated,
 * @return 1 if the elliptic curve file could not be loaded,
 * @return 2 if the Jupiter output file could not be created,
 * @return 3 if the Polyphemus output file could not be created,
 * @return 4 if the Io output file could not be created.
 * @warning Be sure that the ARCANA file is in the correct format or this will lead to an unpredictable behavior.
 * @note There is no need to call SecurityInit() when using this function, it is completely independant from the others.
 */
int SecurityGenerateKeys(char *String_Elliptic_Curve_File_Path, char *String_Jupiter_File_Path, char *String_Polyphemus_File_Path, char *String_Io_File_Path);

/** Load all security needed parameters from various files.
 * @param String_Keys_File_Path Path to the file containing the elliptic curve, the publics and the private keys. This file is generated by the function SecurityGenerateKeys().
 * @param String_Counters_File_Path Path to the anti replay counter.
 * @param Others_Public_Keys_Count How many other machines' public keys to load from the file (1 for a client, more than 1 for a server). The same number of counters are loaded from the counters file.
 * @param Pointer_Elliptic_Curve On output, will contain the loaded elliptic curve.
 * @param Pointer_Point_Own_Public_Key On output, will contain this machine's public key.
 * @param Private_Key On output, will contain this machine's private key.
 * @param Point_Others_Public_Keys On output, will contain all requested other machines' public keys.
 * @param Counters On output, will contain all requested counters.
 * @return 0 if all parameters have been successfully loaded,
 * @return 1 if the keys file could not be loaded or has a bad format,
 * @return 2 if the counter(s) file could not be loaded or has a bad format.
 * @warning All the provided output variables will be initialized internally, do not initialize them yourself (however, you will have to free them when needed).
 */
int SecurityInit(char *String_Keys_File_Path, char *String_Counters_File_Path, int Others_Public_Keys_Count, TEllipticCurve *Pointer_Elliptic_Curve, TPoint *Pointer_Point_Own_Public_Key, mpz_t Private_Key, TPoint Point_Others_Public_Keys[], int Counters[]);

/** Fill authentication message payload by creating a key part used in the Diffie-Hellman keys exchange.
 * @param Counter The counter value to put in the message.
 * @param Pointer_Elliptic_Curve The elliptic curve used for calculations.
 * @param Output_Random_Number On output, will contain the Diffie-Hellman random number needed to compute the whole key.
 * @param Pointer_Message On output, will fill payload fields of the provided message.
 * @warning This function does not sign the message.
 */
void SecurityFillAuthenticationMessage(int Counter, TEllipticCurve *Pointer_Elliptic_Curve, mpz_t Output_Random_Number, TSecurityMessageAuthentication *Pointer_Message);

/** Sign an authentication message with the own private key.
 * @param Pointer_Elliptic_Curve The elliptic curve used for calculations.
 * @param Private_Key The private key used for signature.
 * @param Pointer_Message The message to sign.
 * @warning You must fill the message before signing it.
 */
void SecuritySignAuthenticationMessage(TEllipticCurve *Pointer_Elliptic_Curve, mpz_t Private_Key, TSecurityMessageAuthentication *Pointer_Message);

/** Check an authentication message signature.
 * @param Pointer_Message The message to check.
 * @param Pointer_Elliptic_Curve The elliptic curve used for calculations.
 * @param Pointer_Point_Public_Key The message sender's public key used to check the signature correctness.
 * @param Received_Signature_Number_U The message U number value.
 * @param Received_Signature_Number_V The message V number value.
 * @return 1 if the signature matched or 0 if not.
 */
int SecurityCheckAuthenticationMessageSignature(TSecurityMessageAuthentication *Pointer_Message, TEllipticCurve *Pointer_Elliptic_Curve, TPoint *Pointer_Point_Public_Key, mpz_t Received_Signature_Number_U, mpz_t Received_Signature_Number_V);

/** Receive an authentication message.
 * @param Socket_Source The socket from which to receive the message.
 * @param Pointer_Message On output, contain the raw received message.
 * @param Pointer_Received_Counter On output, contain the counter extracted from the message.
 * @param Pointer_Point_Received_Key_Part On output, contain the received Diffie-Hellman key part.
 * @param Received_Signature_Number_U On output, contain the ECDSA signature U number.
 * @param Received_Signature_Number_V On output, contain the ECDSA signature V number.
 * @return 1 if the message counter could be successfully received or 0 if the function could not read from the provided socket.
 */
int SecurityReceiveAuthenticationMessage(int Socket_Source, TSecurityMessageAuthentication *Pointer_Message, int *Pointer_Received_Counter, TPoint *Pointer_Point_Received_Key_Part, mpz_t Received_Signature_Number_U, mpz_t Received_Signature_Number_V);

/** Send an authentication message.
 * @param Socket_Destination The message recipient.
 * @param Pointer_Message The message to send.
 * @return 1 if the message was correctly sent or 0 if the socket write failed.
 */
int SecuritySendAuthenticationMessage(int Socket_Destination, TSecurityMessageAuthentication *Pointer_Message);

/** Save counter(s) to the same file from which they were loaded.
 * @param Counters The counters values.
 * @param Counters_Count How many counters to save.
 */
void SecuritySaveCounters(int Counters[], int Counters_Count);

/** Send a preformated message containing command or data to the robot in a secure way.
 * @param Socket_Destination The message recipient socket.
 * @param Pointer_AES_Context The AES context used to cipher the stream.
 * @param Data The message data (command or other).
 * @return 1 if the message was successfully sent or 0 if an error occured.
 */
int SecuritySendRobotControlMessage(int Socket_Destination, EVP_CIPHER_CTX *Pointer_AES_Context, int Data);

/** Receive a preformated message containing command or data to the robot in a secure way.
 * @param Socket_Source The socket from which to read message.
 * @param Pointer_AES_Context The AES context used to decipher the stream.
 * @param Pointer_Received_Data On output, contain the message data.
 * @return 1 if the message was successfully received or 0 if an error occured.
 */
int SecurityReceiveRobotControlMessage(int Socket_Source, EVP_CIPHER_CTX *Pointer_AES_Context, int *Pointer_Received_Data);

#endif
