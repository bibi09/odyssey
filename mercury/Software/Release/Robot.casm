;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.21
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/** @file Driver_ADC.c
 * @see Driver_ADC.h for description.
 * @author Adrien RICCIARDI
 */
#include <system.h>
#include "Driver_ADC.h"

void ADCInit(void)

{
	// Configure ADC pin as input
	trisa.0 = 1;
0213  1683  	BSF STATUS, RP0
0214  1303  	BCF STATUS, RP1
0215  1405  	BSF gbl_trisa,0

	
	// Configure module
	adcon1 = 0x8E; // Result is right justified, select only RA0 as analog input
0216  308E  	MOVLW 0x8E
0217  009F  	MOVWF gbl_adcon1

	adcon0 = 0x41; // Use a conversion clock of Fosc/8, select channel 0, enable module 
0218  3041  	MOVLW 0x41
0219  1283  	BCF STATUS, RP0
021A  009F  	MOVWF gbl_adcon0

}
021B  0008  	RETURN


unsigned short ADCReadWord(void)

{
	// Start conversion
	adcon0.GO = 1;
0201  1283  	BCF STATUS, RP0
0202  1303  	BCF STATUS, RP1
0203  151F  	BSF gbl_adcon0,2

	
	// Wait for conversion to finish
	while (adcon0.GO);
0204        label36
0204  191F  	BTFSC gbl_adcon0,2
0205  2A04  	GOTO	label36

	return ((adresh << 8) & 0xFF00) | adresl;
0206  01B2  	CLRF CompTempVarRet650
0207  081E  	MOVF gbl_adresh, W
0208  00B1  	MOVWF CompTempVar656
0209  3000  	MOVLW 0x00
020A  05B2  	ANDWF CompTempVarRet650, F
020B  0831  	MOVF CompTempVar656, W
020C  39FF  	ANDLW 0xFF
020D  00B3  	MOVWF CompTempVarRet650+D'1'
020E  1683  	BSF STATUS, RP0
020F  081E  	MOVF gbl_adresl, W
0210  1283  	BCF STATUS, RP0
0211  04B2  	IORWF CompTempVarRet650, F

}
0212  0008  	RETURN

}
/** @file Driver_EEPROM.c
 * @see Driver_EEPROM.h for description.
 * @author Adrien RICCIARDI
 */
#include <system.h>
#include "Driver_EEPROM.h"

//---------------------------------------------------------------------------------------------------------------
// Private functions
//---------------------------------------------------------------------------------------------------------------
/** Read a byte from the internal EEPROM.
 * @param Address The EEPROM location to read from.
 * @return The read byte value.
 */
static unsigned char EEPROMReadByte(unsigned char Address)

{
	eeadr = Address;
0167  0836  	MOVF EEPROMRead_0001F_arg_Address, W
0168  1703  	BSF STATUS, RP1
0169  008D  	MOVWF gbl_eeadr

	
	// Do read operation
	eecon1.EEPGD = 0; // Select EEPROM memory
016A  1683  	BSF STATUS, RP0
016B  138C  	BCF gbl_eecon1,7

	eecon1.RD = 1; // Start reading
016C  140C  	BSF gbl_eecon1,0

	
	// Wait for the read operation to finish
	while (eecon1.RD);
016D        label32
016D  180C  	BTFSC gbl_eecon1,0
016E  296D  	GOTO	label32

	
	return eedata;
016F  1283  	BCF STATUS, RP0
0170  080C  	MOVF gbl_eedata, W
0171  1303  	BCF STATUS, RP1
0172  00B7  	MOVWF CompTempVarRet662

}
0173  0008  	RETURN


/** Write a byte to the internal EEPROM.
 * @param Address The EEPROM location to write to.
 * @param Byte The value to write.
 */
static void EEPROMWriteByte(unsigned char Address, unsigned char Byte)

{
	// Set location and data to write
	eeadr = Address;
0097  0843  	MOVF EEPROMWrit_00020_arg_Address, W
0098  1703  	BSF STATUS, RP1
0099  008D  	MOVWF gbl_eeadr

	eedata = Byte;
009A  1303  	BCF STATUS, RP1
009B  0844  	MOVF EEPROMWrit_00020_arg_Byte, W
009C  1703  	BSF STATUS, RP1
009D  008C  	MOVWF gbl_eedata

	
	// Disable interrupts
	intcon.GIE = 0;
009E  138B  	BCF gbl_intcon,7

	
	// Configure write operation
	eecon1.EEPGD = 0; // Select EEPROM memory
009F  1683  	BSF STATUS, RP0
00A0  138C  	BCF gbl_eecon1,7

	eecon1.WREN = 1; // Enable writing to the EEPROM
00A1  150C  	BSF gbl_eecon1,2

	
	// Do special write sequence
	eecon2 = 0x55;
00A2  3055  	MOVLW 0x55
00A3  008D  	MOVWF gbl_eecon2

	eecon2 = 0xAA;
00A4  30AA  	MOVLW 0xAA
00A5  008D  	MOVWF gbl_eecon2

	eecon1.WR = 1; // Start write operation
00A6  148C  	BSF gbl_eecon1,1

	
	// Wait for the write operation to finish
	while (eecon1.WR);
00A7        label12
00A7  188C  	BTFSC gbl_eecon1,1
00A8  28A7  	GOTO	label12

	
	// Disable writing to the EEPROM
	eecon1.WREN = 0;
00A9  110C  	BCF gbl_eecon1,2

	
	// Reenable interrupts
	intcon.GIE = 1;
00AA  178B  	BSF gbl_intcon,7

}
00AB  0008  	RETURN


//---------------------------------------------------------------------------------------------------------------
// Public functions
//---------------------------------------------------------------------------------------------------------------
unsigned short EEPROMReadWord(unsigned char Address)

{
	unsigned short Return_Value = 0;
0174  01B2  	CLRF EEPROMRead_0001B_1_Return_Value
0175  01B3  	CLRF EEPROMRead_0001B_1_Return_Value+D'1'

	unsigned char High_Byte, Low_Byte;
	
	if (Address < EEPROM_SIZE_BYTES - 1)
0176  30FF  	MOVLW 0xFF
0177  0231  	SUBWF EEPROMRead_0001B_arg_Address, W
0178  1803  	BTFSC STATUS,C
0179  298D  	GOTO	label33
018D        label33

	{
		// Retrieve little-endian data
		Low_Byte = EEPROMReadByte(Address); // Low order byte
017A  0831  	MOVF EEPROMRead_0001B_arg_Address, W
017B  00B6  	MOVWF EEPROMRead_0001F_arg_Address
017C  2167  	CALL EEPROMRead_0001F
017D  0837  	MOVF CompTempVarRet662, W
017E  00B5  	MOVWF EEPROMRead_0001B_1_Low_Byte

		High_Byte = EEPROMReadByte(Address + 1); // High order byte
017F  0A31  	INCF EEPROMRead_0001B_arg_Address, W
0180  00B6  	MOVWF EEPROMRead_0001F_arg_Address
0181  2167  	CALL EEPROMRead_0001F
0182  0837  	MOVF CompTempVarRet662, W
0183  00B4  	MOVWF EEPROMRead_0001B_1_High_Byte

		Return_Value = (High_Byte << 8) | Low_Byte;
0184  01B6  	CLRF CompTempVar660
0185  0834  	MOVF EEPROMRead_0001B_1_High_Byte, W
0186  00B7  	MOVWF CompTempVar661
0187  0835  	MOVF EEPROMRead_0001B_1_Low_Byte, W
0188  04B6  	IORWF CompTempVar660, F
0189  0836  	MOVF CompTempVar660, W
018A  00B2  	MOVWF EEPROMRead_0001B_1_Return_Value
018B  0837  	MOVF CompTempVar661, W
018C  00B3  	MOVWF EEPROMRead_0001B_1_Return_Value+D'1'

	}
		
	return Return_Value;
018D  0832  	MOVF EEPROMRead_0001B_1_Return_Value, W
018E  00B6  	MOVWF CompTempVarRet657
018F  0833  	MOVF EEPROMRead_0001B_1_Return_Value+D'1', W
0190  00B7  	MOVWF CompTempVarRet657+D'1'

}
0191  0008  	RETURN


void EEPROMWriteWord(unsigned char Address, unsigned short Word)

{
	if (Address < EEPROM_SIZE_BYTES - 1)
00AC  30FF  	MOVLW 0xFF
00AD  0240  	SUBWF EEPROMWrit_0001C_arg_Address, W
00AE  1803  	BTFSC STATUS,C

	{
		// Store data in little-endian form
		EEPROMWriteByte(Address, Word);
00B0  0840  	MOVF EEPROMWrit_0001C_arg_Address, W
00B1  00C3  	MOVWF EEPROMWrit_00020_arg_Address
00B2  0841  	MOVF EEPROMWrit_0001C_arg_Word, W
00B3  00C4  	MOVWF EEPROMWrit_00020_arg_Byte
00B4  2097  	CALL EEPROMWrit_00020

		EEPROMWriteByte(Address + 1, Word >> 8);
00B5  1283  	BCF STATUS, RP0
00B6  1303  	BCF STATUS, RP1
00B7  0A40  	INCF EEPROMWrit_0001C_arg_Address, W
00B8  00C3  	MOVWF EEPROMWrit_00020_arg_Address
00B9  0842  	MOVF EEPROMWrit_0001C_arg_Word+D'1', W
00BA  00C4  	MOVWF EEPROMWrit_00020_arg_Byte
00BB  2097  	CALL EEPROMWrit_00020

	}
}
00AF  0008  	RETURN
00BC  0008  	RETURN

}
/** @file Driver_UART.c
 * @see Driver_UART.h for description.
 * @author Adrien RICCIARDI
 */
#include <system.h>
#include "Driver_UART.h"

void UARTInit(unsigned char Baud_Rate)

{
	// Set UART pins as inputs
	trisc.7 = 1;
0192  1683  	BSF STATUS, RP0
0193  1787  	BSF gbl_trisc,7

	trisc.6 = 1;
0194  1707  	BSF gbl_trisc,6

	
	// Configure module
	spbrg = Baud_Rate; // Set baud rate
0195  1283  	BCF STATUS, RP0
0196  0831  	MOVF UARTInit_00000_arg_Baud_Rate, W
0197  1683  	BSF STATUS, RP0
0198  0099  	MOVWF gbl_spbrg

	txsta = 0x26; // 8-bit transmission, transmission enabled, high speed
0199  3026  	MOVLW 0x26
019A  0098  	MOVWF gbl_txsta

	rcsta = 0x90; // Reception and serial port module enabled
019B  3090  	MOVLW 0x90
019C  1283  	BCF STATUS, RP0
019D  0098  	MOVWF gbl_rcsta

}
019E  0008  	RETURN


unsigned char UARTReadByte(void)

{
	// Check if an overrun error happened
	if (rcsta.OERR)
00C2  1283  	BCF STATUS, RP0
00C3  1303  	BCF STATUS, RP1
00C4  1C98  	BTFSS gbl_rcsta,1
00C5  28C9  	GOTO	label14
00C9        label14

	{
		// Clear error
		rcsta.OERR = 0;
00C6  1098  	BCF gbl_rcsta,1

		
		// Reset receiver logic to reenable reception
		rcsta.CREN = 0;
00C7  1218  	BCF gbl_rcsta,4

		rcsta.CREN = 1;
00C8  1618  	BSF gbl_rcsta,4

	}

	// Wait for data to be received
	while (!pir1.RCIF);
00C9  1E8C  	BTFSS gbl_pir1,5
00CA  28C9  	GOTO	label14

	// Get data
	return rcreg;
00CB  081A  	MOVF gbl_rcreg, W
00CC  00BD  	MOVWF CompTempVarRet663

}
00CD  0008  	RETURN


void UARTWriteByte(unsigned char Byte)

{
	// Wait until the Tx line becomes available
	while (!pir1.TXIF);
00BD        label13
00BD  1E0C  	BTFSS gbl_pir1,4
00BE  28BD  	GOTO	label13

	// Send data
	txreg = Byte;
00BF  083D  	MOVF UARTWriteB_00016_arg_Byte, W
00C0  0099  	MOVWF gbl_txreg

}
00C1  0008  	RETURN

}
/** @file Main.c
 * Main loop.
 * @author Adrien RICCIARDI
 * @version 1.0 : 15/12/2013
 * @version 1.1 : 01/03/2014, added motor speed calibration feature.
 * @version 1.2 : 02/03/2014, added magic number check to avoid UART glitches.
 */
#include <system.h>
#include "Driver_UART.h"
#include "Driver_ADC.h"
#include "Robot.h"
#include "Motor.h"

//---------------------------------------------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------------------------------------------
// Configure PIC16F876 fuses
#pragma DATA _CONFIG, _PWRTE_ON & _BODEN_ON & _WDT_OFF & _LVP_OFF & _CPD_OFF & _DEBUG_OFF & _XT_OSC & _CP_OFF
// Configure clock frequency (Hz)
#pragma CLOCK_FREQ 3686400

//---------------------------------------------------------------------------------------------------------------
// Global variables
//---------------------------------------------------------------------------------------------------------------
static unsigned short Battery_Voltage;
0243  01A3  	CLRF gbl_19_Battery_Voltage
0244  01A4  	CLRF gbl_19_Battery_Voltage+D'1'


//---------------------------------------------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------------------------------------------
void interrupt(void)

{
	static unsigned char Is_Magic_Number_Received = 0;
0240  1283  	BCF STATUS, RP0
0241  1303  	BCF STATUS, RP1
0242  102D  	BCF CompGblVar73,0
0252  1283  	BCF STATUS, RP0
0253  1303  	BCF STATUS, RP1
0254  182D  	BTFSC CompGblVar73,0
0255  2A58  	GOTO	label39
0256  01AE  	CLRF interrupt_1_Is_Magic_Numbe_00021
0257  142D  	BSF CompGblVar73,0
0258        label39

	unsigned char Command;
	TMotor Motor;
	TMotorState State;
	TMotorDirection Direction;
	
	// Handle UART receive interrupt
	if (UARTHasInterruptOccured())
0258  1E8C  	BTFSS gbl_pir1,5
0259  2AC5  	GOTO	label57
02C5        label57

	{
		Command = UARTReadByte();
025A  20C2  	CALL UARTReadBy_00015
025B  083D  	MOVF CompTempVarRet663, W
025C  00B8  	MOVWF interrupt_1_Command

		
		// Wait for a leading magic number
		if (!Is_Magic_Number_Received)
025D  08AE  	MOVF interrupt_1_Is_Magic_Numbe_00021, F
025E  1D03  	BTFSS STATUS,Z
025F  2A68  	GOTO	label41
0268        label41

		{
			if (Command == ROBOT_COMMAND_MAGIC_NUMBER) Is_Magic_Number_Received = 1;
0260  0838  	MOVF interrupt_1_Command, W
0261  3AA5  	XORLW 0xA5
0262  1D03  	BTFSS STATUS,Z
0263  2A66  	GOTO	label40
0264  3001  	MOVLW 0x01
0265  00AE  	MOVWF interrupt_1_Is_Magic_Numbe_00021
0266        label40

			// Re-enable UART interrupt
			UARTClearInterruptFlag();
0266  128C  	BCF gbl_pir1,5

			return;
0267  2AC5  	GOTO	label57

		}
		
		// Reached when the magic number was previously received
		Is_Magic_Number_Received = 0; // Reset for next instruction
0268  01AE  	CLRF interrupt_1_Is_Magic_Numbe_00021

		
		// Check command opcode
		switch (Command & ROBOT_COMMANDS_CODE_MASK)
0269  30C0  	MOVLW 0xC0
026A  0538  	ANDWF interrupt_1_Command, W
026B  00BC  	MOVWF CompTempVar664
0279  2AC4  	GOTO	label56
02C4        label56

		{
			// Set motor state
			case ROBOT_COMMAND_SET_MOTOR_STATE:
026C  083C  	MOVF CompTempVar664, W
026D  3A00  	XORLW 0x00
026E  1903  	BTFSC STATUS,Z
026F  2A7A  	GOTO	label42
027A        label42

				// Extract motor ID
				if (Command & 0x20) Motor = MOTOR_RIGHT;
027A  1EB8  	BTFSS interrupt_1_Command,5
027B  2A7F  	GOTO	label43
027C  3001  	MOVLW 0x01
027D  00B9  	MOVWF interrupt_1_Motor
027F        label43

				else Motor = MOTOR_LEFT;
027E  2A80  	GOTO	label44
027F  01B9  	CLRF interrupt_1_Motor
0280        label44

				
				// Extract requested state
				Command = (Command >> 3) & 0x03;
0280  0CB8  	RRF interrupt_1_Command, F
0281  0CB8  	RRF interrupt_1_Command, F
0282  0CB8  	RRF interrupt_1_Command, F
0283  301F  	MOVLW 0x1F
0284  05B8  	ANDWF interrupt_1_Command, F
0285  3003  	MOVLW 0x03
0286  05B8  	ANDWF interrupt_1_Command, F

				if (Command == 1) State = MOTOR_STATE_FORWARD;
0287  0338  	DECF interrupt_1_Command, W
0288  1D03  	BTFSS STATUS,Z
0289  2A8D  	GOTO	label45
028A  3001  	MOVLW 0x01
028B  00BA  	MOVWF interrupt_1_State
028D        label45

				else if (Command == 2) State = MOTOR_STATE_BACKWARD;
028C  2A95  	GOTO	label47
028D  0838  	MOVF interrupt_1_Command, W
028E  3A02  	XORLW 0x02
028F  1D03  	BTFSS STATUS,Z
0290  2A94  	GOTO	label46
0291  3002  	MOVLW 0x02
0292  00BA  	MOVWF interrupt_1_State
0294        label46

				else State = MOTOR_STATE_STOPPED; // So an unknown state will stop the motor
0293  2A95  	GOTO	label47
0294  01BA  	CLRF interrupt_1_State
0295        label47

				
				// Apply new state
				MotorSetState(Motor, State);
0295  0839  	MOVF interrupt_1_Motor, W
0296  00C5  	MOVWF MotorSetSt_00018_arg_Motor
0297  083A  	MOVF interrupt_1_State, W
0298  00C6  	MOVWF MotorSetSt_00018_arg_State
0299  202D  	CALL MotorSetSt_00018

				break;
029A  2AC4  	GOTO	label56

				
			// Light or turn off the green LED
			case ROBOT_COMMAND_SET_LED_STATE:
0270  3A40  	XORLW 0x40
0271  1903  	BTFSC STATUS,Z
0272  2A9B  	GOTO	label48
029B        label48

				// Bit 5 tells the led state
				if (Command & 40) RobotLedOn();
029B  3028  	MOVLW 0x28
029C  0538  	ANDWF interrupt_1_Command, W
029D  1903  	BTFSC STATUS,Z
029E  2AA1  	GOTO	label49
029F  1786  	BSF gbl_portb,7
02A1        label49

				else RobotLedOff();
02A0  2AC4  	GOTO	label56
02A1  1386  	BCF gbl_portb,7

				break;
02A2  2AC4  	GOTO	label56

				
			// Return the last sampled battery voltage value
			case ROBOT_COMMAND_READ_BATTERY_VOLTAGE:
0273  3AC0  	XORLW 0xC0
0274  1903  	BTFSC STATUS,Z
0275  2AA3  	GOTO	label50
02A3        label50

				// Send value in big endian mode
				UARTWriteByte(Battery_Voltage >> 8);
02A3  0824  	MOVF gbl_19_Battery_Voltage+D'1', W
02A4  00BD  	MOVWF UARTWriteB_00016_arg_Byte
02A5  20BD  	CALL UARTWriteB_00016

				UARTWriteByte(Battery_Voltage);
02A6  0823  	MOVF gbl_19_Battery_Voltage, W
02A7  00BD  	MOVWF UARTWriteB_00016_arg_Byte
02A8  20BD  	CALL UARTWriteB_00016

				break;
02A9  2AC4  	GOTO	label56

				
			// Increase or decrease motor speed
			case ROBOT_COMMAND_CHANGE_MOTOR_SPEED:
0276  3A40  	XORLW 0x40
0277  1903  	BTFSC STATUS,Z
0278  2AAA  	GOTO	label51
02AA        label51

				// Extract motor ID
				if (Command & 0x20) Motor = MOTOR_RIGHT;
02AA  1EB8  	BTFSS interrupt_1_Command,5
02AB  2AAF  	GOTO	label52
02AC  3001  	MOVLW 0x01
02AD  00B9  	MOVWF interrupt_1_Motor
02AF        label52

				else Motor = MOTOR_LEFT;
02AE  2AB0  	GOTO	label53
02AF  01B9  	CLRF interrupt_1_Motor
02B0        label53

				
				// Extract direction
				if (Command & 0x10) Direction = MOTOR_DIRECTION_BACKWARD;
02B0  1E38  	BTFSS interrupt_1_Command,4
02B1  2AB5  	GOTO	label54
02B2  3001  	MOVLW 0x01
02B3  00BB  	MOVWF interrupt_1_Direction
02B5        label54

				else Direction = MOTOR_DIRECTION_FORWARD;
02B4  2AB6  	GOTO	label55
02B5  01BB  	CLRF interrupt_1_Direction
02B6        label55

				
				// Extract speed
				Command = (Command & 0x08) >> 3;
02B6  3008  	MOVLW 0x08
02B7  05B8  	ANDWF interrupt_1_Command, F
02B8  0CB8  	RRF interrupt_1_Command, F
02B9  0CB8  	RRF interrupt_1_Command, F
02BA  0CB8  	RRF interrupt_1_Command, F
02BB  301F  	MOVLW 0x1F
02BC  05B8  	ANDWF interrupt_1_Command, F

				
				MotorChangeSpeed(Motor, Direction, Command);
02BD  0839  	MOVF interrupt_1_Motor, W
02BE  00BD  	MOVWF MotorChang_00019_arg_Motor
02BF  083B  	MOVF interrupt_1_Direction, W
02C0  00BE  	MOVWF MotorChang_00019_arg_Direction
02C1  0838  	MOVF interrupt_1_Command, W
02C2  00BF  	MOVWF MotorChang_00019_arg_Is_Sp_0001A
02C3  20CE  	CALL MotorChang_00019

				break;
		}
	
		// Re-enable UART interrupt
		UARTClearInterruptFlag();
02C4  128C  	BCF gbl_pir1,5

	}
}
02C5  0E22  	SWAPF Int1BContext+D'2', W
02C6  0084  	MOVWF FSR
02C7  0E21  	SWAPF Int1BContext+D'1', W
02C8  008A  	MOVWF PCLATH
02C9  0E20  	SWAPF Int1BContext, W
02CA  0083  	MOVWF STATUS
02CB  0EFF  	SWAPF Int1Context, F
02CC  0E7F  	SWAPF Int1Context, W
02CD  0009  	RETFIE


void main(void)

{
	// Initialize robot
	RobotInit();
021C  1683  	BSF STATUS, RP0
021D  1303  	BCF STATUS, RP1
021E  0186  	CLRF gbl_trisb
021F  1283  	BCF STATUS, RP0
0220  1386  	BCF gbl_portb,7

	MotorInit();
0221  219F  	CALL MotorInit_00000

	ADCInit();
0222  2213  	CALL ADCInit_00000

	UARTInit(UART_BAUD_RATE_115200);
0223  3001  	MOVLW 0x01
0224  00B1  	MOVWF UARTInit_00000_arg_Baud_Rate
0225  2192  	CALL UARTInit_00000

	
	// Stop motors
	MotorSetState(MOTOR_LEFT, MOTOR_STATE_STOPPED);
0226  01C5  	CLRF MotorSetSt_00018_arg_Motor
0227  01C6  	CLRF MotorSetSt_00018_arg_State
0228  202D  	CALL MotorSetSt_00018

	MotorSetState(MOTOR_RIGHT, MOTOR_STATE_STOPPED);
0229  3001  	MOVLW 0x01
022A  00C5  	MOVWF MotorSetSt_00018_arg_Motor
022B  01C6  	CLRF MotorSetSt_00018_arg_State
022C  202D  	CALL MotorSetSt_00018

		
	// Turn off LED to let master light it when it has finished booting
	RobotLedOff();
022D  1386  	BCF gbl_portb,7

	
	// Do some fake reads to calibrate ADC
	ADCReadWord();
022E  2201  	CALL ADCReadWor_00017

	ADCReadWord();
022F  2201  	CALL ADCReadWor_00017

	
	// Enable interrupts
	intcon = 0xC0;
0230  30C0  	MOVLW 0xC0
0231  008B  	MOVWF gbl_intcon

	
	// Main loop
	while (1)
0232        label37
023F  2A32  	GOTO	label37

	{
		// Read battery voltage each second
		UARTDisableInterrupt(); // Atomic operation
0232  1683  	BSF STATUS, RP0
0233  128C  	BCF gbl_pie1,5

		Battery_Voltage = ADCReadWord();
0234  2201  	CALL ADCReadWor_00017
0235  0832  	MOVF CompTempVarRet650, W
0236  00A3  	MOVWF gbl_19_Battery_Voltage
0237  0833  	MOVF CompTempVarRet650+D'1', W
0238  00A4  	MOVWF gbl_19_Battery_Voltage+D'1'

		UARTEnableInterrupt();
0239  1683  	BSF STATUS, RP0
023A  168C  	BSF gbl_pie1,5

		delay_s(1);
023B  3001  	MOVLW 0x01
023C  1283  	BCF STATUS, RP0
023D  00B1  	MOVWF delay_s_00000_arg_del
023E  201E  	CALL delay_s_00000

	}
}

}
/** @file Motor.c
 * @see Motor.h for description.
 * @author Adrien RICCIARDI
 */
#include <system.h>
#include "Driver_EEPROM.h"
#include "Motor.h"

//---------------------------------------------------------------------------------------------------------------
// Private constants
//---------------------------------------------------------------------------------------------------------------
// PWM pins
#define MOTOR_LEFT_PIN 2
#define MOTOR_RIGHT_PIN 1

// Duty cycle values to make each motor rotate forward and backward
#define MOTOR_LEFT_DEFAULT_DUTY_CYCLE_FORWARD 200
#define MOTOR_LEFT_DEFAULT_DUTY_CYCLE_BACKWARD 500
#define MOTOR_RIGHT_DEFAULT_DUTY_CYCLE_FORWARD 800
#define MOTOR_RIGHT_DEFAULT_DUTY_CYCLE_BACKWARD 300

// EEPROM addresses of motor speed values
#define MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD 0
#define MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD 2
#define MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD 4
#define MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD 6

// PWM hardware limits
#define MOTOR_MINIMUM_DUTY_CYCLE_VALUE 0
#define MOTOR_MAXIMUM_DUTY_CYCLE_VALUE 1023

//---------------------------------------------------------------------------------------------------------------
// Private variables
//---------------------------------------------------------------------------------------------------------------
static unsigned short Motor_Left_Duty_Cycle_Forward, Motor_Left_Duty_Cycle_Backward, Motor_Right_Duty_Cycle_Forward, Motor_Right_Duty_Cycle_Backward;
0245  01A5  	CLRF gbl_20_Motor_Left_Duty_Cyc_00000
0246  01A6  	CLRF gbl_20_Motor_Left_Duty_Cyc_00000+D'1'
0247  01A7  	CLRF gbl_20_Motor_Left_Duty_Cyc_00001
0248  01A8  	CLRF gbl_20_Motor_Left_Duty_Cyc_00001+D'1'
0249  01A9  	CLRF gbl_20_Motor_Right_Duty_Cy_00002
024A  01AA  	CLRF gbl_20_Motor_Right_Duty_Cy_00002+D'1'
024B  01AB  	CLRF gbl_20_Motor_Right_Duty_Cy_00003
024C  01AC  	CLRF gbl_20_Motor_Right_Duty_Cy_00003+D'1'

static TMotorState Motor_Left_State, Motor_Right_State; // Keep current states to allow MotorChangeSpeed() to reset them
024D  01AF  	CLRF gbl_20_Motor_Left_State
024E  01B0  	CLRF gbl_20_Motor_Right_State


//---------------------------------------------------------------------------------------------------------------
// Public functions
//---------------------------------------------------------------------------------------------------------------
void MotorInit(void)

{	
	// Configure PWM pins as outputs
	trisc.MOTOR_LEFT_PIN = 0;
019F  1683  	BSF STATUS, RP0
01A0  1303  	BCF STATUS, RP1
01A1  1107  	BCF gbl_trisc,2

	trisc.MOTOR_RIGHT_PIN = 0;
01A2  1087  	BCF gbl_trisc,1

	
	// Stop motors
	portc.MOTOR_LEFT_PIN = 0;
01A3  1283  	BCF STATUS, RP0
01A4  1107  	BCF gbl_portc,2

	portc.MOTOR_RIGHT_PIN = 0;
01A5  1087  	BCF gbl_portc,1

	
	// Check if the EEPROM contains the duty cycle values
	Motor_Left_Duty_Cycle_Forward = EEPROMReadWord(MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD);
01A6  01B1  	CLRF EEPROMRead_0001B_arg_Address
01A7  2174  	CALL EEPROMRead_0001B
01A8  0836  	MOVF CompTempVarRet657, W
01A9  00A5  	MOVWF gbl_20_Motor_Left_Duty_Cyc_00000
01AA  0837  	MOVF CompTempVarRet657+D'1', W
01AB  00A6  	MOVWF gbl_20_Motor_Left_Duty_Cyc_00000+D'1'

	
	// Is the EEPROM memory empty ?
	if (Motor_Left_Duty_Cycle_Forward == 0xFFFF)
01AC  0825  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000, W
01AD  3AFF  	XORLW 0xFF
01AE  30FF  	MOVLW 0xFF
01AF  1903  	BTFSC STATUS,Z
01B0  0626  	XORWF gbl_20_Motor_Left_Duty_Cyc_00000+D'1', W
01B1  1D03  	BTFSS STATUS,Z
01B2  29E5  	GOTO	label34
01E5        label34

	{
		// Write default duty cycles to EEPROM
		EEPROMWriteWord(MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD, MOTOR_LEFT_DEFAULT_DUTY_CYCLE_FORWARD);
01B3  01C0  	CLRF EEPROMWrit_0001C_arg_Address
01B4  30C8  	MOVLW 0xC8
01B5  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
01B6  01C2  	CLRF EEPROMWrit_0001C_arg_Word+D'1'
01B7  20AC  	CALL EEPROMWrit_0001C

		EEPROMWriteWord(MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD, MOTOR_LEFT_DEFAULT_DUTY_CYCLE_BACKWARD);
01B8  3002  	MOVLW 0x02
01B9  1283  	BCF STATUS, RP0
01BA  1303  	BCF STATUS, RP1
01BB  00C0  	MOVWF EEPROMWrit_0001C_arg_Address
01BC  30F4  	MOVLW 0xF4
01BD  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
01BE  3001  	MOVLW 0x01
01BF  00C2  	MOVWF EEPROMWrit_0001C_arg_Word+D'1'
01C0  20AC  	CALL EEPROMWrit_0001C

		EEPROMWriteWord(MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD, MOTOR_RIGHT_DEFAULT_DUTY_CYCLE_FORWARD);
01C1  3004  	MOVLW 0x04
01C2  1283  	BCF STATUS, RP0
01C3  1303  	BCF STATUS, RP1
01C4  00C0  	MOVWF EEPROMWrit_0001C_arg_Address
01C5  3020  	MOVLW 0x20
01C6  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
01C7  3003  	MOVLW 0x03
01C8  00C2  	MOVWF EEPROMWrit_0001C_arg_Word+D'1'
01C9  20AC  	CALL EEPROMWrit_0001C

		EEPROMWriteWord(MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD, MOTOR_RIGHT_DEFAULT_DUTY_CYCLE_BACKWARD);
01CA  3006  	MOVLW 0x06
01CB  1283  	BCF STATUS, RP0
01CC  1303  	BCF STATUS, RP1
01CD  00C0  	MOVWF EEPROMWrit_0001C_arg_Address
01CE  302C  	MOVLW 0x2C
01CF  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
01D0  3001  	MOVLW 0x01
01D1  00C2  	MOVWF EEPROMWrit_0001C_arg_Word+D'1'
01D2  20AC  	CALL EEPROMWrit_0001C

	
		// Use default values
		Motor_Left_Duty_Cycle_Forward = MOTOR_LEFT_DEFAULT_DUTY_CYCLE_FORWARD;
01D3  30C8  	MOVLW 0xC8
01D4  1283  	BCF STATUS, RP0
01D5  1303  	BCF STATUS, RP1
01D6  00A5  	MOVWF gbl_20_Motor_Left_Duty_Cyc_00000
01D7  01A6  	CLRF gbl_20_Motor_Left_Duty_Cyc_00000+D'1'

		Motor_Left_Duty_Cycle_Backward = MOTOR_LEFT_DEFAULT_DUTY_CYCLE_BACKWARD;
01D8  30F4  	MOVLW 0xF4
01D9  00A7  	MOVWF gbl_20_Motor_Left_Duty_Cyc_00001
01DA  3001  	MOVLW 0x01
01DB  00A8  	MOVWF gbl_20_Motor_Left_Duty_Cyc_00001+D'1'

		Motor_Right_Duty_Cycle_Forward = MOTOR_RIGHT_DEFAULT_DUTY_CYCLE_FORWARD;
01DC  3020  	MOVLW 0x20
01DD  00A9  	MOVWF gbl_20_Motor_Right_Duty_Cy_00002
01DE  3003  	MOVLW 0x03
01DF  00AA  	MOVWF gbl_20_Motor_Right_Duty_Cy_00002+D'1'

		Motor_Right_Duty_Cycle_Backward = MOTOR_RIGHT_DEFAULT_DUTY_CYCLE_BACKWARD;
01E0  302C  	MOVLW 0x2C
01E1  00AB  	MOVWF gbl_20_Motor_Right_Duty_Cy_00003
01E2  3001  	MOVLW 0x01
01E3  00AC  	MOVWF gbl_20_Motor_Right_Duty_Cy_00003+D'1'

	}
	else
01E4  29FA  	GOTO	label35
01FA        label35

	{
		// Load values from EEPROM
		Motor_Left_Duty_Cycle_Backward = EEPROMReadWord(MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD);
01E5  3002  	MOVLW 0x02
01E6  00B1  	MOVWF EEPROMRead_0001B_arg_Address
01E7  2174  	CALL EEPROMRead_0001B
01E8  0836  	MOVF CompTempVarRet657, W
01E9  00A7  	MOVWF gbl_20_Motor_Left_Duty_Cyc_00001
01EA  0837  	MOVF CompTempVarRet657+D'1', W
01EB  00A8  	MOVWF gbl_20_Motor_Left_Duty_Cyc_00001+D'1'

		Motor_Right_Duty_Cycle_Forward = EEPROMReadWord(MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD);
01EC  3004  	MOVLW 0x04
01ED  00B1  	MOVWF EEPROMRead_0001B_arg_Address
01EE  2174  	CALL EEPROMRead_0001B
01EF  0836  	MOVF CompTempVarRet657, W
01F0  00A9  	MOVWF gbl_20_Motor_Right_Duty_Cy_00002
01F1  0837  	MOVF CompTempVarRet657+D'1', W
01F2  00AA  	MOVWF gbl_20_Motor_Right_Duty_Cy_00002+D'1'

		Motor_Right_Duty_Cycle_Backward = EEPROMReadWord(MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD);
01F3  3006  	MOVLW 0x06
01F4  00B1  	MOVWF EEPROMRead_0001B_arg_Address
01F5  2174  	CALL EEPROMRead_0001B
01F6  0836  	MOVF CompTempVarRet657, W
01F7  00AB  	MOVWF gbl_20_Motor_Right_Duty_Cy_00003
01F8  0837  	MOVF CompTempVarRet657+D'1', W
01F9  00AC  	MOVWF gbl_20_Motor_Right_Duty_Cy_00003+D'1'

	}
	
	// Set the PWM period to 4.44 ms (it is the longuest we can achieve with a 3.6864 MHz clock)
	pr2 = 255;
01FA  30FF  	MOVLW 0xFF
01FB  1683  	BSF STATUS, RP0
01FC  0092  	MOVWF gbl_pr2

	t2con = 0x06; // Enable timer 2 and set a 16x prescaler
01FD  3006  	MOVLW 0x06
01FE  1283  	BCF STATUS, RP0
01FF  0092  	MOVWF gbl_t2con

}
0200  0008  	RETURN


void MotorSetState(TMotor Motor, TMotorState State)

{
	unsigned char *Pointer_CCPCON_Register, *Pointer_CCPRL_Register;
	unsigned short Duty_Cycle;
	
	// Get the configuration registers corresponding to the selected motor
	if (Motor == MOTOR_LEFT)
002D  08C5  	MOVF MotorSetSt_00018_arg_Motor, F
002E  1D03  	BTFSS STATUS,Z
002F  283B  	GOTO	label4
003B        label4

	{
		Pointer_CCPCON_Register = &ccp1con;
0030  3000  	MOVLW HIGH(gbl_ccp1con+D'0')
0031  00C8  	MOVWF MotorSetSt_00018_1_Pointer_00022+D'1'
0032  3017  	MOVLW LOW(gbl_ccp1con+D'0')
0033  00C7  	MOVWF MotorSetSt_00018_1_Pointer_00022

		Pointer_CCPRL_Register = &ccpr1l;
0034  3000  	MOVLW HIGH(gbl_ccpr1l+D'0')
0035  00CA  	MOVWF MotorSetSt_00018_1_Pointer_00023+D'1'
0036  3015  	MOVLW LOW(gbl_ccpr1l+D'0')
0037  00C9  	MOVWF MotorSetSt_00018_1_Pointer_00023

		Motor_Left_State = State;
0038  0846  	MOVF MotorSetSt_00018_arg_State, W
0039  00AF  	MOVWF gbl_20_Motor_Left_State

	}
	else
003A  2849  	GOTO	label5
0049        label5

	{
		Pointer_CCPCON_Register = &ccp2con;
003B  3000  	MOVLW HIGH(gbl_ccp2con+D'0')
003C  00CD  	MOVWF CompTempVar670
003D  301D  	MOVLW LOW(gbl_ccp2con+D'0')
003E  00C7  	MOVWF MotorSetSt_00018_1_Pointer_00022
003F  084D  	MOVF CompTempVar670, W
0040  00C8  	MOVWF MotorSetSt_00018_1_Pointer_00022+D'1'

		Pointer_CCPRL_Register = &ccpr2l;
0041  3000  	MOVLW HIGH(gbl_ccpr2l+D'0')
0042  00CD  	MOVWF CompTempVar671
0043  301B  	MOVLW LOW(gbl_ccpr2l+D'0')
0044  00C9  	MOVWF MotorSetSt_00018_1_Pointer_00023
0045  084D  	MOVF CompTempVar671, W
0046  00CA  	MOVWF MotorSetSt_00018_1_Pointer_00023+D'1'

		Motor_Right_State = State;
0047  0846  	MOVF MotorSetSt_00018_arg_State, W
0048  00B0  	MOVWF gbl_20_Motor_Right_State

	}
	
	// Choose the right duty cycle according to selected state
	switch (State)
0053  2875  	GOTO	label11

	{
		case MOTOR_STATE_STOPPED:
0049  0846  	MOVF MotorSetSt_00018_arg_State, W
004A  3A00  	XORLW 0x00
004B  1903  	BTFSC STATUS,Z
004C  2854  	GOTO	label6
0054        label6

			*Pointer_CCPCON_Register = 0; // Stop PWM
0054  1383  	BCF STATUS,IRP
0055  1848  	BTFSC MotorSetSt_00018_1_Pointer_00022+D'1',0
0056  1783  	BSF STATUS,IRP
0057  0847  	MOVF MotorSetSt_00018_1_Pointer_00022, W
0058  0084  	MOVWF FSR
0059  3000  	MOVLW 0x00
005A  0080  	MOVWF INDF

			return;
			
		case MOTOR_STATE_FORWARD:
004D  3A01  	XORLW 0x01
004E  1903  	BTFSC STATUS,Z
004F  285C  	GOTO	label7
005C        label7

			if (Motor == MOTOR_LEFT) Duty_Cycle = Motor_Left_Duty_Cycle_Forward;
005C  08C5  	MOVF MotorSetSt_00018_arg_Motor, F
005D  1D03  	BTFSS STATUS,Z
005E  2864  	GOTO	label8
005F  0825  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000, W
0060  00CB  	MOVWF MotorSetSt_00018_1_Duty_Cycle
0061  0826  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000+D'1', W
0062  00CC  	MOVWF MotorSetSt_00018_1_Duty_Cycle+D'1'
0064        label8

			else Duty_Cycle = Motor_Right_Duty_Cycle_Forward;
0063  2875  	GOTO	label11
0064  0829  	MOVF gbl_20_Motor_Right_Duty_Cy_00002, W
0065  00CB  	MOVWF MotorSetSt_00018_1_Duty_Cycle
0066  082A  	MOVF gbl_20_Motor_Right_Duty_Cy_00002+D'1', W
0067  00CC  	MOVWF MotorSetSt_00018_1_Duty_Cycle+D'1'

			break;
0068  2875  	GOTO	label11

			
		case MOTOR_STATE_BACKWARD:
0050  3A03  	XORLW 0x03
0051  1903  	BTFSC STATUS,Z
0052  2869  	GOTO	label9
0069        label9

			if (Motor == MOTOR_LEFT) Duty_Cycle = Motor_Left_Duty_Cycle_Backward;
0069  08C5  	MOVF MotorSetSt_00018_arg_Motor, F
006A  1D03  	BTFSS STATUS,Z
006B  2871  	GOTO	label10
006C  0827  	MOVF gbl_20_Motor_Left_Duty_Cyc_00001, W
006D  00CB  	MOVWF MotorSetSt_00018_1_Duty_Cycle
006E  0828  	MOVF gbl_20_Motor_Left_Duty_Cyc_00001+D'1', W
006F  00CC  	MOVWF MotorSetSt_00018_1_Duty_Cycle+D'1'
0071        label10

			else Duty_Cycle = Motor_Right_Duty_Cycle_Backward;
0070  2875  	GOTO	label11
0071  082B  	MOVF gbl_20_Motor_Right_Duty_Cy_00003, W
0072  00CB  	MOVWF MotorSetSt_00018_1_Duty_Cycle
0073  082C  	MOVF gbl_20_Motor_Right_Duty_Cy_00003+D'1', W
0074  00CC  	MOVWF MotorSetSt_00018_1_Duty_Cycle+D'1'
0075        label11

			break;
	}
	
	// Apply new duty cycle
	*Pointer_CCPCON_Register = (Duty_Cycle << 4) & 0x30;  // Stop this motor PWM and set duty cycle least significant bits in the same time
0075  0E4B  	SWAPF MotorSetSt_00018_1_Duty_Cycle, W
0076  39F0  	ANDLW 0xF0
0077  00CD  	MOVWF CompTempVar673
0078  3030  	MOVLW 0x30
0079  05CD  	ANDWF CompTempVar673, F
007A  1383  	BCF STATUS,IRP
007B  1848  	BTFSC MotorSetSt_00018_1_Pointer_00022+D'1',0
007C  1783  	BSF STATUS,IRP
007D  0847  	MOVF MotorSetSt_00018_1_Pointer_00022, W
007E  0084  	MOVWF FSR
007F  084D  	MOVF CompTempVar673, W
0080  0080  	MOVWF INDF

	*Pointer_CCPRL_Register = Duty_Cycle >> 2; // Set duty cycle most significant bits
0081  084B  	MOVF MotorSetSt_00018_1_Duty_Cycle, W
0082  00CD  	MOVWF CompTempVar674
0083  0C4C  	RRF MotorSetSt_00018_1_Duty_Cycle+D'1', W
0084  00CE  	MOVWF CompTempVar675
0085  0CCD  	RRF CompTempVar674, F
0086  0CCE  	RRF CompTempVar675, F
0087  0CCD  	RRF CompTempVar674, F
0088  1383  	BCF STATUS,IRP
0089  184A  	BTFSC MotorSetSt_00018_1_Pointer_00023+D'1',0
008A  1783  	BSF STATUS,IRP
008B  0849  	MOVF MotorSetSt_00018_1_Pointer_00023, W
008C  0084  	MOVWF FSR
008D  084D  	MOVF CompTempVar674, W
008E  0080  	MOVWF INDF

	*Pointer_CCPCON_Register |= 0x0C; // Re-enable motor PWM
008F  1383  	BCF STATUS,IRP
0090  1848  	BTFSC MotorSetSt_00018_1_Pointer_00022+D'1',0
0091  1783  	BSF STATUS,IRP
0092  0847  	MOVF MotorSetSt_00018_1_Pointer_00022, W
0093  0084  	MOVWF FSR
0094  300C  	MOVLW 0x0C
0095  0480  	IORWF INDF, F

}
005B  0008  	RETURN
0096  0008  	RETURN


void MotorChangeSpeed(TMotor Motor, TMotorDirection Direction, unsigned char Is_Speed_Increased)

{
	// The left motor is mounted in the opposite direction than the right motor
	if (Motor == MOTOR_LEFT)
00CE  08BD  	MOVF MotorChang_00019_arg_Motor, F
00CF  1D03  	BTFSS STATUS,Z
00D0  291B  	GOTO	label23
011B        label23

	{
		if (Direction == MOTOR_DIRECTION_FORWARD)
00D1  08BE  	MOVF MotorChang_00019_arg_Direction, F
00D2  1D03  	BTFSS STATUS,Z
00D3  28F4  	GOTO	label18
00F4        label18

		{
			if (Is_Speed_Increased)
00D4  08BF  	MOVF MotorChang_00019_arg_Is_Sp_0001A, F
00D5  1903  	BTFSC STATUS,Z
00D6  28E2  	GOTO	label15
00E2        label15

			{
				if (Motor_Left_Duty_Cycle_Forward > MOTOR_MINIMUM_DUTY_CYCLE_VALUE) Motor_Left_Duty_Cycle_Forward--;
00D7  0825  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000, W
00D8  3C00  	SUBLW 0x00
00D9  1803  	BTFSC STATUS,C
00DA  0826  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000+D'1', W
00DB  1903  	BTFSC STATUS,Z
00DC  28ED  	GOTO	label17
00DD  08A5  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000, F
00DE  1903  	BTFSC STATUS,Z
00DF  03A6  	DECF gbl_20_Motor_Left_Duty_Cyc_00000+D'1', F
00E0  03A5  	DECF gbl_20_Motor_Left_Duty_Cyc_00000, F

			}
			else
00E1  28ED  	GOTO	label17

			{
				if (Motor_Left_Duty_Cycle_Forward < MOTOR_MAXIMUM_DUTY_CYCLE_VALUE) Motor_Left_Duty_Cycle_Forward++;
00E2  3003  	MOVLW 0x03
00E3  0226  	SUBWF gbl_20_Motor_Left_Duty_Cyc_00000+D'1', W
00E4  1D03  	BTFSS STATUS,Z
00E5  28E8  	GOTO	label16
00E6  30FF  	MOVLW 0xFF
00E7  0225  	SUBWF gbl_20_Motor_Left_Duty_Cyc_00000, W
00E8        label16
00E8  1803  	BTFSC STATUS,C
00E9  28ED  	GOTO	label17
00EA  0AA5  	INCF gbl_20_Motor_Left_Duty_Cyc_00000, F
00EB  1903  	BTFSC STATUS,Z
00EC  0AA6  	INCF gbl_20_Motor_Left_Duty_Cyc_00000+D'1', F
00ED        label17

			}
			EEPROMWriteWord(MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD, Motor_Left_Duty_Cycle_Forward);
00ED  01C0  	CLRF EEPROMWrit_0001C_arg_Address
00EE  0825  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000, W
00EF  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
00F0  0826  	MOVF gbl_20_Motor_Left_Duty_Cyc_00000+D'1', W
00F1  00C2  	MOVWF EEPROMWrit_0001C_arg_Word+D'1'
00F2  20AC  	CALL EEPROMWrit_0001C

		}
		else
00F3  2914  	GOTO	label22
0114        label22

		{
			if (Is_Speed_Increased)
00F4  08BF  	MOVF MotorChang_00019_arg_Is_Sp_0001A, F
00F5  1903  	BTFSC STATUS,Z
00F6  2903  	GOTO	label20
0103        label20

			{
				if (Motor_Left_Duty_Cycle_Backward < MOTOR_MAXIMUM_DUTY_CYCLE_VALUE) Motor_Left_Duty_Cycle_Backward++; // Motor is mounted in the opposite direction
00F7  3003  	MOVLW 0x03
00F8  0228  	SUBWF gbl_20_Motor_Left_Duty_Cyc_00001+D'1', W
00F9  1D03  	BTFSS STATUS,Z
00FA  28FD  	GOTO	label19
00FB  30FF  	MOVLW 0xFF
00FC  0227  	SUBWF gbl_20_Motor_Left_Duty_Cyc_00001, W
00FD        label19
00FD  1803  	BTFSC STATUS,C
00FE  290D  	GOTO	label21
00FF  0AA7  	INCF gbl_20_Motor_Left_Duty_Cyc_00001, F
0100  1903  	BTFSC STATUS,Z
0101  0AA8  	INCF gbl_20_Motor_Left_Duty_Cyc_00001+D'1', F

			}
			else
0102  290D  	GOTO	label21

			{
				if (Motor_Left_Duty_Cycle_Backward > MOTOR_MINIMUM_DUTY_CYCLE_VALUE) Motor_Left_Duty_Cycle_Backward--;
0103  0827  	MOVF gbl_20_Motor_Left_Duty_Cyc_00001, W
0104  3C00  	SUBLW 0x00
0105  1803  	BTFSC STATUS,C
0106  0828  	MOVF gbl_20_Motor_Left_Duty_Cyc_00001+D'1', W
0107  1903  	BTFSC STATUS,Z
0108  290D  	GOTO	label21
0109  08A7  	MOVF gbl_20_Motor_Left_Duty_Cyc_00001, F
010A  1903  	BTFSC STATUS,Z
010B  03A8  	DECF gbl_20_Motor_Left_Duty_Cyc_00001+D'1', F
010C  03A7  	DECF gbl_20_Motor_Left_Duty_Cyc_00001, F
010D        label21

			}
			EEPROMWriteWord(MOTOR_LEFT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD, Motor_Left_Duty_Cycle_Backward);
010D  3002  	MOVLW 0x02
010E  00C0  	MOVWF EEPROMWrit_0001C_arg_Address
010F  0827  	MOVF gbl_20_Motor_Left_Duty_Cyc_00001, W
0110  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
0111  0828  	MOVF gbl_20_Motor_Left_Duty_Cyc_00001+D'1', W
0112  00C2  	MOVWF EEPROMWrit_0001C_arg_Word+D'1'
0113  20AC  	CALL EEPROMWrit_0001C

		}
		
		// Set new speed
		MotorSetState(MOTOR_LEFT, Motor_Left_State);
0114  1283  	BCF STATUS, RP0
0115  1303  	BCF STATUS, RP1
0116  01C5  	CLRF MotorSetSt_00018_arg_Motor
0117  082F  	MOVF gbl_20_Motor_Left_State, W
0118  00C6  	MOVWF MotorSetSt_00018_arg_State
0119  202D  	CALL MotorSetSt_00018

	}
	else
	{
		if (Direction == MOTOR_DIRECTION_FORWARD)
011B  08BE  	MOVF MotorChang_00019_arg_Direction, F
011C  1D03  	BTFSS STATUS,Z
011D  293F  	GOTO	label27
013F        label27

		{
			if (Is_Speed_Increased)
011E  08BF  	MOVF MotorChang_00019_arg_Is_Sp_0001A, F
011F  1903  	BTFSC STATUS,Z
0120  292D  	GOTO	label25
012D        label25

			{
				if (Motor_Right_Duty_Cycle_Forward < MOTOR_MAXIMUM_DUTY_CYCLE_VALUE) Motor_Right_Duty_Cycle_Forward++;
0121  3003  	MOVLW 0x03
0122  022A  	SUBWF gbl_20_Motor_Right_Duty_Cy_00002+D'1', W
0123  1D03  	BTFSS STATUS,Z
0124  2927  	GOTO	label24
0125  30FF  	MOVLW 0xFF
0126  0229  	SUBWF gbl_20_Motor_Right_Duty_Cy_00002, W
0127        label24
0127  1803  	BTFSC STATUS,C
0128  2937  	GOTO	label26
0129  0AA9  	INCF gbl_20_Motor_Right_Duty_Cy_00002, F
012A  1903  	BTFSC STATUS,Z
012B  0AAA  	INCF gbl_20_Motor_Right_Duty_Cy_00002+D'1', F

			}
			else
012C  2937  	GOTO	label26

			{
				if (Motor_Right_Duty_Cycle_Forward > MOTOR_MINIMUM_DUTY_CYCLE_VALUE) Motor_Right_Duty_Cycle_Forward--;
012D  0829  	MOVF gbl_20_Motor_Right_Duty_Cy_00002, W
012E  3C00  	SUBLW 0x00
012F  1803  	BTFSC STATUS,C
0130  082A  	MOVF gbl_20_Motor_Right_Duty_Cy_00002+D'1', W
0131  1903  	BTFSC STATUS,Z
0132  2937  	GOTO	label26
0133  08A9  	MOVF gbl_20_Motor_Right_Duty_Cy_00002, F
0134  1903  	BTFSC STATUS,Z
0135  03AA  	DECF gbl_20_Motor_Right_Duty_Cy_00002+D'1', F
0136  03A9  	DECF gbl_20_Motor_Right_Duty_Cy_00002, F
0137        label26

			}
			EEPROMWriteWord(MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_FORWARD, Motor_Right_Duty_Cycle_Forward);
0137  3004  	MOVLW 0x04
0138  00C0  	MOVWF EEPROMWrit_0001C_arg_Address
0139  0829  	MOVF gbl_20_Motor_Right_Duty_Cy_00002, W
013A  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
013B  082A  	MOVF gbl_20_Motor_Right_Duty_Cy_00002+D'1', W
013C  00C2  	MOVWF EEPROMWrit_0001C_arg_Word+D'1'
013D  20AC  	CALL EEPROMWrit_0001C

		}
		else
013E  295F  	GOTO	label31
015F        label31

		{
			if (Is_Speed_Increased)
013F  08BF  	MOVF MotorChang_00019_arg_Is_Sp_0001A, F
0140  1903  	BTFSC STATUS,Z
0141  294D  	GOTO	label28
014D        label28

			{
				if (Motor_Right_Duty_Cycle_Backward > MOTOR_MINIMUM_DUTY_CYCLE_VALUE) Motor_Right_Duty_Cycle_Backward--;
0142  082B  	MOVF gbl_20_Motor_Right_Duty_Cy_00003, W
0143  3C00  	SUBLW 0x00
0144  1803  	BTFSC STATUS,C
0145  082C  	MOVF gbl_20_Motor_Right_Duty_Cy_00003+D'1', W
0146  1903  	BTFSC STATUS,Z
0147  2958  	GOTO	label30
0148  08AB  	MOVF gbl_20_Motor_Right_Duty_Cy_00003, F
0149  1903  	BTFSC STATUS,Z
014A  03AC  	DECF gbl_20_Motor_Right_Duty_Cy_00003+D'1', F
014B  03AB  	DECF gbl_20_Motor_Right_Duty_Cy_00003, F

			}
			else
014C  2958  	GOTO	label30

			{
				if (Motor_Right_Duty_Cycle_Backward < MOTOR_MAXIMUM_DUTY_CYCLE_VALUE) Motor_Right_Duty_Cycle_Backward++;
014D  3003  	MOVLW 0x03
014E  022C  	SUBWF gbl_20_Motor_Right_Duty_Cy_00003+D'1', W
014F  1D03  	BTFSS STATUS,Z
0150  2953  	GOTO	label29
0151  30FF  	MOVLW 0xFF
0152  022B  	SUBWF gbl_20_Motor_Right_Duty_Cy_00003, W
0153        label29
0153  1803  	BTFSC STATUS,C
0154  2958  	GOTO	label30
0155  0AAB  	INCF gbl_20_Motor_Right_Duty_Cy_00003, F
0156  1903  	BTFSC STATUS,Z
0157  0AAC  	INCF gbl_20_Motor_Right_Duty_Cy_00003+D'1', F
0158        label30

			}
			EEPROMWriteWord(MOTOR_RIGHT_EEPROM_ADDRESS_DUTY_CYCLE_BACKWARD, Motor_Right_Duty_Cycle_Backward);
0158  3006  	MOVLW 0x06
0159  00C0  	MOVWF EEPROMWrit_0001C_arg_Address
015A  082B  	MOVF gbl_20_Motor_Right_Duty_Cy_00003, W
015B  00C1  	MOVWF EEPROMWrit_0001C_arg_Word
015C  082C  	MOVF gbl_20_Motor_Right_Duty_Cy_00003+D'1', W
015D  00C2  	MOVWF EEPROMWrit_0001C_arg_Word+D'1'
015E  20AC  	CALL EEPROMWrit_0001C

		}
		
		// Set new speed
		MotorSetState(MOTOR_RIGHT, Motor_Right_State);
015F  3001  	MOVLW 0x01
0160  1283  	BCF STATUS, RP0
0161  1303  	BCF STATUS, RP1
0162  00C5  	MOVWF MotorSetSt_00018_arg_Motor
0163  0830  	MOVF gbl_20_Motor_Right_State, W
0164  00C6  	MOVWF MotorSetSt_00018_arg_State
0165  202D  	CALL MotorSetSt_00018

	}
}
011A  0008  	RETURN
0166  0008  	RETURN

		
		
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2A40  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00A0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00A1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00A2  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A52  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08B2  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  3099  	MOVLW 0x99
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  3EFF  	ADDLW 0xFF
0018  1D03  	BTFSS STATUS,Z
0019  2815  	GOTO	label2
001A  0000  	NOP
001B  0BB2  	DECFSZ delay_ms_00000_arg_del, F
001C  2814  	GOTO	label1
001D  0008  	RETURN
001E        ; } delay_ms function end

001E        delay_s_00000
001E        ; { delay_s ; function begin
001E        label3
001E  30FA  	MOVLW 0xFA
001F  00B2  	MOVWF delay_ms_00000_arg_del
0020  2010  	CALL delay_ms_00000
0021  30FA  	MOVLW 0xFA
0022  00B2  	MOVWF delay_ms_00000_arg_del
0023  2010  	CALL delay_ms_00000
0024  30FA  	MOVLW 0xFA
0025  00B2  	MOVWF delay_ms_00000_arg_del
0026  2010  	CALL delay_ms_00000
0027  30FA  	MOVLW 0xFA
0028  00B2  	MOVWF delay_ms_00000_arg_del
0029  2010  	CALL delay_ms_00000
002A  0BB1  	DECFSZ delay_s_00000_arg_del, F
002B  281E  	GOTO	label3
002C  0008  	RETURN
002D        ; } delay_s function end


0240        _startup


024F  118A  	BCF PCLATH,3
0250  120A  	BCF PCLATH,4
0251  2A1C  	GOTO	main

2007  3F71  	DW 0x3F71
