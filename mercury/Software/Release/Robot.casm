;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/** Main.c
 * Main loop.
 * @author Adrien RICCIARDI
 * @version 1.0 : 15/12/2013
 */
#include <system.h>
#include "Driver_UART.h"
#include "Driver_ADC.h"
#include "Robot.h"
#include "Motor.h"

//---------------------------------------------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------------------------------------------
// Configure PIC16F876 fuses
#pragma DATA _CONFIG, _PWRTE_ON & _BODEN_ON & _WDT_OFF & _LVP_OFF & _CPD_OFF & _DEBUG_OFF & _XT_OSC & _CP_OFF
// Configure clock frequency (Hz)
#pragma CLOCK_FREQ 3686400

//---------------------------------------------------------------------------------------------------------------
// Global variables
//---------------------------------------------------------------------------------------------------------------
unsigned short Battery_Voltage;

//---------------------------------------------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------------------------------------------
void interrupt(void)

{
	unsigned char Command;

	TMotor Motor;
	TMotorState State;
	
	// Handle UART receive interrupt
	if (UARTHasInterruptOccured())
0100  1283  	BCF STATUS, RP0
0101  1303  	BCF STATUS, RP1
0102  1E8C  	BTFSS gbl_pir1,5
0103  2945  	GOTO	label28
0145        label28

	{
		Command = UARTReadByte();
0104  2092  	CALL UARTReadBy_00011
0105  082D  	MOVF CompTempVarRet629, W
0106  00A8  	MOVWF interrupt_1_Command

		
		// Check command opcode
		switch (Command & ROBOT_COMMANDS_CODE_MASK)
0107  30C0  	MOVLW 0xC0
0108  0528  	ANDWF interrupt_1_Command, W
0109  00AB  	MOVWF CompTempVar630

		{
			// Set motor state
			case ROBOT_COMMAND_SET_MOTOR_STATE:
010A  082B  	MOVF CompTempVar630, W
010B  3A00  	XORLW 0x00
010C  1903  	BTFSC STATUS,Z
010D  2915  	GOTO	label18
0115        label18

				// Extract motor ID
				if (Command & 0x20) Motor = Right;
0115  1EA8  	BTFSS interrupt_1_Command,5
0116  291A  	GOTO	label19
0117  3001  	MOVLW 0x01
0118  00A9  	MOVWF interrupt_1_Motor
011A        label19

				else Motor = Left;
0119  291B  	GOTO	label20
011A  01A9  	CLRF interrupt_1_Motor
011B        label20

				
				// Extract requested state
				Command = (Command >> 3) & 0x03;
011B  0CA8  	RRF interrupt_1_Command, F
011C  0CA8  	RRF interrupt_1_Command, F
011D  0CA8  	RRF interrupt_1_Command, F
011E  301F  	MOVLW 0x1F
011F  05A8  	ANDWF interrupt_1_Command, F
0120  3003  	MOVLW 0x03
0121  05A8  	ANDWF interrupt_1_Command, F

				if (Command == 1) State = Forward;
0122  0328  	DECF interrupt_1_Command, W
0123  1D03  	BTFSS STATUS,Z
0124  2928  	GOTO	label21
0125  3001  	MOVLW 0x01
0126  00AA  	MOVWF interrupt_1_State
0128        label21

				else if (Command == 2) State = Backward;
0127  2930  	GOTO	label23
0128  0828  	MOVF interrupt_1_Command, W
0129  3A02  	XORLW 0x02
012A  1D03  	BTFSS STATUS,Z
012B  292F  	GOTO	label22
012C  3002  	MOVLW 0x02
012D  00AA  	MOVWF interrupt_1_State
012F        label22

				else State = Stopped; // So an unknown state will stop the motor
012E  2930  	GOTO	label23
012F  01AA  	CLRF interrupt_1_State
0130        label23

				
				// Apply new state
				MotorSetState(Motor, State);
0130  0829  	MOVF interrupt_1_Motor, W
0131  00AE  	MOVWF MotorSetSt_00014_arg_Motor
0132  082A  	MOVF interrupt_1_State, W
0133  00AF  	MOVWF MotorSetSt_00014_arg_State
0134  202D  	CALL MotorSetSt_00014

				break;
0135  2944  	GOTO	label27

				
			// Light or turn off the green LED
			case ROBOT_COMMAND_SET_LED_STATE:
010E  3A40  	XORLW 0x40
010F  1903  	BTFSC STATUS,Z
0110  2936  	GOTO	label24
0136        label24

				// Bit 5 tells the led state
				if (Command & 40) RobotLedOn();
0136  3028  	MOVLW 0x28
0137  0528  	ANDWF interrupt_1_Command, W
0138  1903  	BTFSC STATUS,Z
0139  293C  	GOTO	label25
013A  1786  	BSF gbl_portb,7
013C        label25

				else RobotLedOff();
013B  2944  	GOTO	label27
013C  1386  	BCF gbl_portb,7

				break;
013D  2944  	GOTO	label27

				
			// Return the last sampled battery voltage value
			case ROBOT_COMMAND_READ_BATTERY_VOLTAGE:
0111  3AC0  	XORLW 0xC0
0112  1903  	BTFSC STATUS,Z
0113  293E  	GOTO	label26
013E        label26

				// Send value in big endian mode
				UARTWriteByte(Battery_Voltage >> 8);
013E  0824  	MOVF gbl_Battery_Voltage+D'1', W
013F  00AC  	MOVWF UARTWriteB_00012_arg_Byte
0140  2099  	CALL UARTWriteB_00012

				UARTWriteByte(Battery_Voltage);
0141  0823  	MOVF gbl_Battery_Voltage, W
0142  00AC  	MOVWF UARTWriteB_00012_arg_Byte
0143  2099  	CALL UARTWriteB_00012

				break;
		
			// Unknown command, do nothing
			default:
0114  2944  	GOTO	label27
0144        label27

				break;
		}
	
		// Re-enable UART interrupt
		UARTClearInterruptFlag();
0144  128C  	BCF gbl_pir1,5

	}
}
0145  0E22  	SWAPF Int1BContext+D'2', W
0146  0084  	MOVWF FSR
0147  0E21  	SWAPF Int1BContext+D'1', W
0148  008A  	MOVWF PCLATH
0149  0E20  	SWAPF Int1BContext, W
014A  0083  	MOVWF STATUS
014B  0EFF  	SWAPF Int1Context, F
014C  0E7F  	SWAPF Int1Context, W
014D  0009  	RETFIE


void main(void)

{
	// Initialize robot
	RobotInit();
00D4  1683  	BSF STATUS, RP0
00D5  1303  	BCF STATUS, RP1
00D6  0186  	CLRF gbl_trisb
00D7  1283  	BCF STATUS, RP0
00D8  1386  	BCF gbl_portb,7

	MotorInit();
00D9  20AB  	CALL MotorInit_00000

	ADCInit();
00DA  20CB  	CALL ADCInit_00000

	UARTInit(UART_BAUD_RATE_115200);
00DB  3001  	MOVLW 0x01
00DC  00A5  	MOVWF UARTInit_00000_arg_Baud_Rate
00DD  209E  	CALL UARTInit_00000

	
	// Stop motors
	MotorSetState(Left, Stopped);
00DE  01AE  	CLRF MotorSetSt_00014_arg_Motor
00DF  01AF  	CLRF MotorSetSt_00014_arg_State
00E0  202D  	CALL MotorSetSt_00014

	MotorSetState(Right, Stopped);
00E1  3001  	MOVLW 0x01
00E2  00AE  	MOVWF MotorSetSt_00014_arg_Motor
00E3  01AF  	CLRF MotorSetSt_00014_arg_State
00E4  202D  	CALL MotorSetSt_00014

		
	// Turn off LED to let master light it when it has finished booting
	RobotLedOff();
00E5  1386  	BCF gbl_portb,7

	
	// Do some fake reads to calibrate ADC
	ADCReadWord();
00E6  20B9  	CALL ADCReadWor_00013

	ADCReadWord();
00E7  20B9  	CALL ADCReadWor_00013

	
	// Wait for the master to send the start code (avoid interpreting false commands sent when master is booting)
	while (UARTReadByte() != ROBOT_START_CODE);
00E8        label15
00E8  2092  	CALL UARTReadBy_00011
00E9  082D  	MOVF CompTempVarRet629, W
00EA  3ACA  	XORLW 0xCA
00EB  1D03  	BTFSS STATUS,Z
00EC  28E8  	GOTO	label15

	
	// Enable interrupts
	intcon = 0xC0;
00ED  30C0  	MOVLW 0xC0
00EE  008B  	MOVWF gbl_intcon

	
	// Main loop
	while (1)
00EF        label16
00FC  28EF  	GOTO	label16

	{
		// Read battery voltage each second
		UARTDisableInterrupt(); // Atomic operation
00EF  1683  	BSF STATUS, RP0
00F0  128C  	BCF gbl_pie1,5

		Battery_Voltage = ADCReadWord();
00F1  20B9  	CALL ADCReadWor_00013
00F2  0826  	MOVF CompTempVarRet622, W
00F3  00A3  	MOVWF gbl_Battery_Voltage
00F4  0827  	MOVF CompTempVarRet622+D'1', W
00F5  00A4  	MOVWF gbl_Battery_Voltage+D'1'

		UARTEnableInterrupt();
00F6  1683  	BSF STATUS, RP0
00F7  168C  	BSF gbl_pie1,5

		delay_s(1);
00F8  3001  	MOVLW 0x01
00F9  1283  	BCF STATUS, RP0
00FA  00A5  	MOVWF delay_s_00000_arg_del
00FB  201E  	CALL delay_s_00000

	}
}

}
/** @file Motor.c
 * @see Motor.h for description.
 * @author Adrien RICCIARDI
 */
#include <system.h>
#include "Motor.h"

// The duty cycle value to make the motor rotate in one direction
//#define DUTY_CYCLE_DIRECTION_1 115 //230
// The duty cycle value to make the motor rotate in the opposite direction
//#define DUTY_CYCLE_DIRECTION_2 576 //461
// Duty cycle values to make each motor rotate forward and backward
/*#define MOTOR_LEFT_DUTY_CYCLE_FORWARD 300
#define MOTOR_LEFT_DUTY_CYCLE_BACKWARD 500
#define MOTOR_RIGHT_DUTY_CYCLE_FORWARD 461
#define MOTOR_RIGHT_DUTY_CYCLE_BACKWARD 230*/

#define MOTOR_LEFT_DUTY_CYCLE_FORWARD 200
#define MOTOR_LEFT_DUTY_CYCLE_BACKWARD 500//450
#define MOTOR_RIGHT_DUTY_CYCLE_FORWARD 800
#define MOTOR_RIGHT_DUTY_CYCLE_BACKWARD 300

void MotorInit(void)

{
	// Configure PWM pins RC1 and RC2 as outputs
	trisc.1 = 0;
00AB  1683  	BSF STATUS, RP0
00AC  1303  	BCF STATUS, RP1
00AD  1087  	BCF gbl_trisc,1

	trisc.2 = 0;
00AE  1107  	BCF gbl_trisc,2

	
	// Stop motors
	portc.1 = 0;
00AF  1283  	BCF STATUS, RP0
00B0  1087  	BCF gbl_portc,1

	portc.2 = 0;
00B1  1107  	BCF gbl_portc,2

	
	// Set the PWM period to 4.44 ms (it is the longuest we can achieve with a 3.6864 MHz clock)
	pr2 = 255;
00B2  30FF  	MOVLW 0xFF
00B3  1683  	BSF STATUS, RP0
00B4  0092  	MOVWF gbl_pr2

	t2con = 0x06; // Enable timer 2 and set a 16x prescaler
00B5  3006  	MOVLW 0x06
00B6  1283  	BCF STATUS, RP0
00B7  0092  	MOVWF gbl_t2con

}
00B8  0008  	RETURN


void MotorSetState(TMotor Motor, TMotorState State)

{
	unsigned char *Pointer_CCPCON_Register, *Pointer_CCPRL_Register;
	unsigned short Duty_Cycle;
	
	// Get the configuration registers corresponding to the selected motor
	if (Motor == Left)
002D  08AE  	MOVF MotorSetSt_00014_arg_Motor, F
002E  1D03  	BTFSS STATUS,Z
002F  2839  	GOTO	label4
0039        label4

	{
		Pointer_CCPCON_Register = &ccp1con;
0030  3000  	MOVLW HIGH(gbl_ccp1con+D'0')
0031  00B1  	MOVWF MotorSetSt_00014_1_Pointer_00017+D'1'
0032  3017  	MOVLW LOW(gbl_ccp1con+D'0')
0033  00B0  	MOVWF MotorSetSt_00014_1_Pointer_00017

		Pointer_CCPRL_Register = &ccpr1l;
0034  3000  	MOVLW HIGH(gbl_ccpr1l+D'0')
0035  00B3  	MOVWF MotorSetSt_00014_1_Pointer_00018+D'1'
0036  3015  	MOVLW LOW(gbl_ccpr1l+D'0')
0037  00B2  	MOVWF MotorSetSt_00014_1_Pointer_00018

	}
	else
0038  2845  	GOTO	label5
0045        label5

	{
		Pointer_CCPCON_Register = &ccp2con;
0039  3000  	MOVLW HIGH(gbl_ccp2con+D'0')
003A  00B6  	MOVWF CompTempVar634
003B  301D  	MOVLW LOW(gbl_ccp2con+D'0')
003C  00B0  	MOVWF MotorSetSt_00014_1_Pointer_00017
003D  0836  	MOVF CompTempVar634, W
003E  00B1  	MOVWF MotorSetSt_00014_1_Pointer_00017+D'1'

		Pointer_CCPRL_Register = &ccpr2l;
003F  3000  	MOVLW HIGH(gbl_ccpr2l+D'0')
0040  00B6  	MOVWF CompTempVar635
0041  301B  	MOVLW LOW(gbl_ccpr2l+D'0')
0042  00B2  	MOVWF MotorSetSt_00014_1_Pointer_00018
0043  0836  	MOVF CompTempVar635, W
0044  00B3  	MOVWF MotorSetSt_00014_1_Pointer_00018+D'1'

	}
	
	// Choose the right duty cycle according to selected state
	switch (State)
004F  2870  	GOTO	label11

	{
		case Stopped:
0045  082F  	MOVF MotorSetSt_00014_arg_State, W
0046  3A00  	XORLW 0x00
0047  1903  	BTFSC STATUS,Z
0048  2850  	GOTO	label6
0050        label6

			*Pointer_CCPCON_Register = 0; // Stop PWM
0050  1383  	BCF STATUS,IRP
0051  1831  	BTFSC MotorSetSt_00014_1_Pointer_00017+D'1',0
0052  1783  	BSF STATUS,IRP
0053  0830  	MOVF MotorSetSt_00014_1_Pointer_00017, W
0054  0084  	MOVWF FSR
0055  3000  	MOVLW 0x00
0056  0080  	MOVWF INDF

			return;
			
		case Forward:
0049  3A01  	XORLW 0x01
004A  1903  	BTFSC STATUS,Z
004B  2858  	GOTO	label7
0058        label7

			if (Motor == Left) Duty_Cycle = MOTOR_LEFT_DUTY_CYCLE_FORWARD;
0058  08AE  	MOVF MotorSetSt_00014_arg_Motor, F
0059  1D03  	BTFSS STATUS,Z
005A  285F  	GOTO	label8
005B  30C8  	MOVLW 0xC8
005C  00B4  	MOVWF MotorSetSt_00014_1_Duty_Cycle
005D  01B5  	CLRF MotorSetSt_00014_1_Duty_Cycle+D'1'
005F        label8

			else Duty_Cycle = MOTOR_RIGHT_DUTY_CYCLE_FORWARD;
005E  2870  	GOTO	label11
005F  3020  	MOVLW 0x20
0060  00B4  	MOVWF MotorSetSt_00014_1_Duty_Cycle
0061  3003  	MOVLW 0x03
0062  00B5  	MOVWF MotorSetSt_00014_1_Duty_Cycle+D'1'

			break;
0063  2870  	GOTO	label11

			
		case Backward:
004C  3A03  	XORLW 0x03
004D  1903  	BTFSC STATUS,Z
004E  2864  	GOTO	label9
0064        label9

			if (Motor == Left) Duty_Cycle = MOTOR_LEFT_DUTY_CYCLE_BACKWARD;
0064  08AE  	MOVF MotorSetSt_00014_arg_Motor, F
0065  1D03  	BTFSS STATUS,Z
0066  286C  	GOTO	label10
0067  30F4  	MOVLW 0xF4
0068  00B4  	MOVWF MotorSetSt_00014_1_Duty_Cycle
0069  3001  	MOVLW 0x01
006A  00B5  	MOVWF MotorSetSt_00014_1_Duty_Cycle+D'1'
006C        label10

			else Duty_Cycle = MOTOR_RIGHT_DUTY_CYCLE_BACKWARD;
006B  2870  	GOTO	label11
006C  302C  	MOVLW 0x2C
006D  00B4  	MOVWF MotorSetSt_00014_1_Duty_Cycle
006E  3001  	MOVLW 0x01
006F  00B5  	MOVWF MotorSetSt_00014_1_Duty_Cycle+D'1'
0070        label11

			break;
	}
	
	// Apply new duty cycle
	*Pointer_CCPCON_Register = (Duty_Cycle << 4) & 0x30;  // Stop this motor PWM and set duty cycle least significant bits in the same time
0070  0E34  	SWAPF MotorSetSt_00014_1_Duty_Cycle, W
0071  39F0  	ANDLW 0xF0
0072  00B6  	MOVWF CompTempVar637
0073  3030  	MOVLW 0x30
0074  05B6  	ANDWF CompTempVar637, F
0075  1383  	BCF STATUS,IRP
0076  1831  	BTFSC MotorSetSt_00014_1_Pointer_00017+D'1',0
0077  1783  	BSF STATUS,IRP
0078  0830  	MOVF MotorSetSt_00014_1_Pointer_00017, W
0079  0084  	MOVWF FSR
007A  0836  	MOVF CompTempVar637, W
007B  0080  	MOVWF INDF

	*Pointer_CCPRL_Register = Duty_Cycle >> 2; // Set duty cycle most significant bits
007C  0834  	MOVF MotorSetSt_00014_1_Duty_Cycle, W
007D  00B6  	MOVWF CompTempVar638
007E  0C35  	RRF MotorSetSt_00014_1_Duty_Cycle+D'1', W
007F  00B7  	MOVWF CompTempVar639
0080  0CB6  	RRF CompTempVar638, F
0081  0CB7  	RRF CompTempVar639, F
0082  0CB6  	RRF CompTempVar638, F
0083  1383  	BCF STATUS,IRP
0084  1833  	BTFSC MotorSetSt_00014_1_Pointer_00018+D'1',0
0085  1783  	BSF STATUS,IRP
0086  0832  	MOVF MotorSetSt_00014_1_Pointer_00018, W
0087  0084  	MOVWF FSR
0088  0836  	MOVF CompTempVar638, W
0089  0080  	MOVWF INDF

	*Pointer_CCPCON_Register |= 0x0C; // Re-enable motor PWM
008A  1383  	BCF STATUS,IRP
008B  1831  	BTFSC MotorSetSt_00014_1_Pointer_00017+D'1',0
008C  1783  	BSF STATUS,IRP
008D  0830  	MOVF MotorSetSt_00014_1_Pointer_00017, W
008E  0084  	MOVWF FSR
008F  300C  	MOVLW 0x0C
0090  0480  	IORWF INDF, F

}
0057  0008  	RETURN
0091  0008  	RETURN

}
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  28FD  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00A0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00A1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00A2  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2900  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08A6  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  3099  	MOVLW 0x99
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  3EFF  	ADDLW 0xFF
0018  1D03  	BTFSS STATUS,Z
0019  2815  	GOTO	label2
001A  0000  	NOP
001B  0BA6  	DECFSZ delay_ms_00000_arg_del, F
001C  2814  	GOTO	label1
001D  0008  	RETURN
001E        ; } delay_ms function end

001E        delay_s_00000
001E        ; { delay_s ; function begin
001E        label3
001E  30FA  	MOVLW 0xFA
001F  00A6  	MOVWF delay_ms_00000_arg_del
0020  2010  	CALL delay_ms_00000
0021  30FA  	MOVLW 0xFA
0022  00A6  	MOVWF delay_ms_00000_arg_del
0023  2010  	CALL delay_ms_00000
0024  30FA  	MOVLW 0xFA
0025  00A6  	MOVWF delay_ms_00000_arg_del
0026  2010  	CALL delay_ms_00000
0027  30FA  	MOVLW 0xFA
0028  00A6  	MOVWF delay_ms_00000_arg_del
0029  2010  	CALL delay_ms_00000
002A  0BA5  	DECFSZ delay_s_00000_arg_del, F
002B  281E  	GOTO	label3
002C  0008  	RETURN
002D        ; } delay_s function end


0092        UARTReadBy_00011
0092        ; { UARTReadByte ; function begin
0092        label12
0092  1283  	BCF STATUS, RP0
0093  1303  	BCF STATUS, RP1
0094  1E8C  	BTFSS gbl_pir1,5
0095  2892  	GOTO	label12
0096  081A  	MOVF gbl_rcreg, W
0097  00AD  	MOVWF CompTempVarRet629
0098  0008  	RETURN
0099        ; } UARTReadByte function end

0099        UARTWriteB_00012
0099        ; { UARTWriteByte ; function begin
0099        label13
0099  1E0C  	BTFSS gbl_pir1,4
009A  2899  	GOTO	label13
009B  082C  	MOVF UARTWriteB_00012_arg_Byte, W
009C  0099  	MOVWF gbl_txreg
009D  0008  	RETURN
009E        ; } UARTWriteByte function end

009E        UARTInit_00000
009E        ; { UARTInit ; function begin
009E  1683  	BSF STATUS, RP0
009F  1787  	BSF gbl_trisc,7
00A0  1707  	BSF gbl_trisc,6
00A1  1283  	BCF STATUS, RP0
00A2  0825  	MOVF UARTInit_00000_arg_Baud_Rate, W
00A3  1683  	BSF STATUS, RP0
00A4  0099  	MOVWF gbl_spbrg
00A5  3026  	MOVLW 0x26
00A6  0098  	MOVWF gbl_txsta
00A7  3090  	MOVLW 0x90
00A8  1283  	BCF STATUS, RP0
00A9  0098  	MOVWF gbl_rcsta
00AA  0008  	RETURN
00AB        ; } UARTInit function end


00B9        ADCReadWor_00013
00B9        ; { ADCReadWord ; function begin
00B9  1283  	BCF STATUS, RP0
00BA  1303  	BCF STATUS, RP1
00BB  151F  	BSF gbl_adcon0,2
00BC        label14
00BC  191F  	BTFSC gbl_adcon0,2
00BD  28BC  	GOTO	label14
00BE  01A6  	CLRF CompTempVarRet622
00BF  081E  	MOVF gbl_adresh, W
00C0  00A5  	MOVWF CompTempVar628
00C1  3000  	MOVLW 0x00
00C2  05A6  	ANDWF CompTempVarRet622, F
00C3  0825  	MOVF CompTempVar628, W
00C4  39FF  	ANDLW 0xFF
00C5  00A7  	MOVWF CompTempVarRet622+D'1'
00C6  1683  	BSF STATUS, RP0
00C7  081E  	MOVF gbl_adresl, W
00C8  1283  	BCF STATUS, RP0
00C9  04A6  	IORWF CompTempVarRet622, F
00CA  0008  	RETURN
00CB        ; } ADCReadWord function end

00CB        ADCInit_00000
00CB        ; { ADCInit ; function begin
00CB  1683  	BSF STATUS, RP0
00CC  1303  	BCF STATUS, RP1
00CD  1405  	BSF gbl_trisa,0
00CE  308E  	MOVLW 0x8E
00CF  009F  	MOVWF gbl_adcon1
00D0  3041  	MOVLW 0x41
00D1  1283  	BCF STATUS, RP0
00D2  009F  	MOVWF gbl_adcon0
00D3  0008  	RETURN
00D4        ; } ADCInit function end


00FD        _startup
00FD  118A  	BCF PCLATH,3
00FE  120A  	BCF PCLATH,4
00FF  28D4  	GOTO	main

2007  3F71  	DW 0x3F71
