;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/** Driver_ADC.c
 * @see Driver_ADC.h for description.
 * @author Adrien RICCIARDI
 */
#include <system.h>
#include "Driver_ADC.h"

void ADCInit(void)

{
	// Configure ADC pin as input
	trisa.0 = 1;
0058  1683  	BSF STATUS, RP0
0059  1303  	BCF STATUS, RP1
005A  1405  	BSF gbl_trisa,0

	
	// Configure module
	adcon1 = 0x8E; // Result is right justified, select only RA0 as analog input
005B  308E  	MOVLW 0x8E
005C  009F  	MOVWF gbl_adcon1

	adcon0 = 0x41; // Use a conversion clock of Fosc/8, select channel 0, enable module 
005D  3041  	MOVLW 0x41
005E  1283  	BCF STATUS, RP0
005F  009F  	MOVWF gbl_adcon0

}
0060  0008  	RETURN


unsigned short ADCReadWord(void)

{
	// Start conversion
	adcon0.GO = 1;
0046  1283  	BCF STATUS, RP0
0047  1303  	BCF STATUS, RP1
0048  151F  	BSF gbl_adcon0,2

	
	// Wait for conversion to finish
	while (adcon0.GO);
0049        label6
0049  191F  	BTFSC gbl_adcon0,2
004A  2849  	GOTO	label6

	return ((adresh << 8) & 0xFF00) | adresl;
004B  01A6  	CLRF CompTempVarRet597
004C  081E  	MOVF gbl_adresh, W
004D  00A5  	MOVWF CompTempVar603
004E  3000  	MOVLW 0x00
004F  05A6  	ANDWF CompTempVarRet597, F
0050  0825  	MOVF CompTempVar603, W
0051  39FF  	ANDLW 0xFF
0052  00A7  	MOVWF CompTempVarRet597+D'1'
0053  1683  	BSF STATUS, RP0
0054  081E  	MOVF gbl_adresl, W
0055  1283  	BCF STATUS, RP0
0056  04A6  	IORWF CompTempVarRet597, F

}
0057  0008  	RETURN

}
/** Driver_UART.c
 * @see Driver_UART.h for description.
 * @author Adrien RICCIARDI
 */
#include <system.h>
#include "Driver_UART.h"

void UARTInit(unsigned char Baud_Rate)

{
	// Set UART pins as inputs
	trisc.7 = 1;
0039  1683  	BSF STATUS, RP0
003A  1787  	BSF gbl_trisc,7

	trisc.6 = 1;
003B  1707  	BSF gbl_trisc,6

	
	// Configure module
	spbrg = Baud_Rate; // Set baud rate
003C  1283  	BCF STATUS, RP0
003D  0825  	MOVF UARTInit_00000_arg_Baud_Rate, W
003E  1683  	BSF STATUS, RP0
003F  0099  	MOVWF gbl_spbrg

	txsta = 0x26; // 8-bit transmission, transmission enabled, high speed
0040  3026  	MOVLW 0x26
0041  0098  	MOVWF gbl_txsta

	rcsta = 0x90; // Reception and serial port module enabled
0042  3090  	MOVLW 0x90
0043  1283  	BCF STATUS, RP0
0044  0098  	MOVWF gbl_rcsta

}
0045  0008  	RETURN


unsigned char UARTReadByte(void)

{
	// Wait for data to be received
	while (!pir1.RCIF);
002D        label4
002D  1283  	BCF STATUS, RP0
002E  1303  	BCF STATUS, RP1
002F  1E8C  	BTFSS gbl_pir1,5
0030  282D  	GOTO	label4

	// Get data
	return rcreg;
0031  081A  	MOVF gbl_rcreg, W
0032  00AA  	MOVWF CompTempVarRet604

}
0033  0008  	RETURN


void UARTWriteByte(unsigned char Byte)

{
	// Wait until the Tx line becomes available
	while (!pir1.TXIF);
0034        label5
0034  1E0C  	BTFSS gbl_pir1,4
0035  2834  	GOTO	label5

	// Send data
	txreg = Byte;
0036  0825  	MOVF UARTWriteB_00012_arg_Byte, W
0037  0099  	MOVWF gbl_txreg

}
0038  0008  	RETURN

}
/** Main.c
 * Main loop.
 * @author Adrien RICCIARDI
 * @version 1.0 : 15/12/2013
 */
#include <system.h>
#include "Driver_UART.h"
#include "Driver_ADC.h"
#include "Robot.h"

//---------------------------------------------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------------------------------------------
// Configure PIC16F876 fuses
#pragma DATA _CONFIG, _PWRTE_ON & _BODEN_ON & _WDT_OFF & _LVP_OFF & _CPD_OFF & _DEBUG_OFF & _XT_OSC & _CP_OFF
// Configure clock frequency (Hz)
#pragma CLOCK_FREQ 3686400

//---------------------------------------------------------------------------------------------------------------
// Global variables
//---------------------------------------------------------------------------------------------------------------
unsigned short Battery_Voltage;

//---------------------------------------------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------------------------------------------
void interrupt(void)

{
	unsigned char Command;

	
	// Handle UART receive interrupt
	if (UARTHasInterruptOccured())
008A  1283  	BCF STATUS, RP0
008B  1303  	BCF STATUS, RP1
008C  1E8C  	BTFSS gbl_pir1,5
008D  28A0  	GOTO	label12
00A0        label12

	{
		Command = UARTReadByte();
008E  202D  	CALL UARTReadBy_00011
008F  082A  	MOVF CompTempVarRet604, W
0090  00A8  	MOVWF interrupt_1_Command

		
		// Check command opcode
		switch (Command & ROBOT_COMMANDS_CODE_MASK)
0091  30C0  	MOVLW 0xC0
0092  0528  	ANDWF interrupt_1_Command, W
0093  00A9  	MOVWF CompTempVar605

		{
			// Light or turn off the green LED
			case ROBOT_COMMAND_SET_LED_STATE:
0094  0829  	MOVF CompTempVar605, W
0095  3A40  	XORLW 0x40
0096  1D03  	BTFSS STATUS,Z

				// Bit 5 tells the led state
				if (Command & 40) RobotLedOn();
0098  3028  	MOVLW 0x28
0099  0528  	ANDWF interrupt_1_Command, W
009A  1903  	BTFSC STATUS,Z
009B  289E  	GOTO	label10
009C  1786  	BSF gbl_portb,7
009E        label10

				else RobotLedOff();
009D  289F  	GOTO	label11
009E  1386  	BCF gbl_portb,7
009F        label11

				break;
		
			// Unknown command
			default:
0097  289F  	GOTO	label11

				break;
		}
	
		// Re-enable UART interrupt
		UARTClearInterruptFlag();
009F  128C  	BCF gbl_pir1,5

	}
}
00A0  0E22  	SWAPF Int1BContext+D'2', W
00A1  0084  	MOVWF FSR
00A2  0E21  	SWAPF Int1BContext+D'1', W
00A3  008A  	MOVWF PCLATH
00A4  0E20  	SWAPF Int1BContext, W
00A5  0083  	MOVWF STATUS
00A6  0EFF  	SWAPF Int1Context, F
00A7  0E7F  	SWAPF Int1Context, W
00A8  0009  	RETFIE


void main(void)

{
	// Initialize robot
	RobotInit();
0061  1683  	BSF STATUS, RP0
0062  1303  	BCF STATUS, RP1
0063  0186  	CLRF gbl_trisb

	UARTInit(UART_BAUD_RATE_115200);
0064  3001  	MOVLW 0x01
0065  1283  	BCF STATUS, RP0
0066  00A5  	MOVWF UARTInit_00000_arg_Baud_Rate
0067  2039  	CALL UARTInit_00000

	ADCInit();
0068  2058  	CALL ADCInit_00000

	
	// Turn off LED to let master light it when it has finished booting
	RobotLedOff();
0069  1386  	BCF gbl_portb,7

	
	// Do some fake reads to calibrate ADC
	ADCReadWord();
006A  2046  	CALL ADCReadWor_00013

	ADCReadWord();
006B  2046  	CALL ADCReadWor_00013

	
	// Wait for the start code (to avoid executing false commands sent by the master during boot)
	while (UARTReadByte() != ROBOT_START_CODE);
006C        label7
006C  202D  	CALL UARTReadBy_00011
006D  082A  	MOVF CompTempVarRet604, W
006E  3ACA  	XORLW 0xCA
006F  1D03  	BTFSS STATUS,Z
0070  286C  	GOTO	label7

	
	// Enable interrupts
	intcon = 0xC0;
0071  30C0  	MOVLW 0xC0
0072  008B  	MOVWF gbl_intcon

	
	// Main loop
	while (1)
0073        label8
0086  2873  	GOTO	label8

	{
		// Read battery voltage each second
		UARTDisableInterrupt(); // Atomic operation
0073  1683  	BSF STATUS, RP0
0074  128C  	BCF gbl_pie1,5

		Battery_Voltage = ADCReadWord();
0075  2046  	CALL ADCReadWor_00013
0076  0826  	MOVF CompTempVarRet597, W
0077  00A3  	MOVWF gbl_Battery_Voltage
0078  0827  	MOVF CompTempVarRet597+D'1', W
0079  00A4  	MOVWF gbl_Battery_Voltage+D'1'

		UARTEnableInterrupt();
007A  1683  	BSF STATUS, RP0
007B  168C  	BSF gbl_pie1,5

		delay_s(1);
007C  3001  	MOVLW 0x01
007D  1283  	BCF STATUS, RP0
007E  00A5  	MOVWF delay_s_00000_arg_del
007F  201E  	CALL delay_s_00000

		
			UARTWriteByte(Battery_Voltage >> 8);
0080  0824  	MOVF gbl_Battery_Voltage+D'1', W
0081  00A5  	MOVWF UARTWriteB_00012_arg_Byte
0082  2034  	CALL UARTWriteB_00012

			UARTWriteByte(Battery_Voltage);
0083  0823  	MOVF gbl_Battery_Voltage, W
0084  00A5  	MOVWF UARTWriteB_00012_arg_Byte
0085  2034  	CALL UARTWriteB_00012

		
	}
}

}
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2887  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00A0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00A1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00A2  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  288A  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08A6  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  3099  	MOVLW 0x99
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  3EFF  	ADDLW 0xFF
0018  1D03  	BTFSS STATUS,Z
0019  2815  	GOTO	label2
001A  0000  	NOP
001B  0BA6  	DECFSZ delay_ms_00000_arg_del, F
001C  2814  	GOTO	label1
001D  0008  	RETURN
001E        ; } delay_ms function end

001E        delay_s_00000
001E        ; { delay_s ; function begin
001E        label3
001E  30FA  	MOVLW 0xFA
001F  00A6  	MOVWF delay_ms_00000_arg_del
0020  2010  	CALL delay_ms_00000
0021  30FA  	MOVLW 0xFA
0022  00A6  	MOVWF delay_ms_00000_arg_del
0023  2010  	CALL delay_ms_00000
0024  30FA  	MOVLW 0xFA
0025  00A6  	MOVWF delay_ms_00000_arg_del
0026  2010  	CALL delay_ms_00000
0027  30FA  	MOVLW 0xFA
0028  00A6  	MOVWF delay_ms_00000_arg_del
0029  2010  	CALL delay_ms_00000
002A  0BA5  	DECFSZ delay_s_00000_arg_del, F
002B  281E  	GOTO	label3
002C  0008  	RETURN
002D        ; } delay_s function end


0087        _startup
0087  118A  	BCF PCLATH,3
0088  120A  	BCF PCLATH,4
0089  2861  	GOTO	main

2007  3F71  	DW 0x3F71
